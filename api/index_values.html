<html>
<head>
<link rel="stylesheet" href="style.css" type="text/css">
<meta content="text/html; charset=iso-8859-1" http-equiv="Content-Type">
<link rel="Start" href="index.html">
<link title="Index of types" rel=Appendix href="index_types.html">
<link title="Index of exceptions" rel=Appendix href="index_exceptions.html">
<link title="Index of values" rel=Appendix href="index_values.html">
<link title="Index of modules" rel=Appendix href="index_modules.html">
<link title="Index of module types" rel=Appendix href="index_module_types.html">
<link title="Blist" rel="Chapter" href="Blist.html">
<link title="Hashset" rel="Chapter" href="Hashset.html">
<link title="Lru" rel="Chapter" href="Lru.html">
<link title="Sigs" rel="Chapter" href="Sigs.html">
<link title="Soundcheck" rel="Chapter" href="Soundcheck.html">
<link title="Proofnode" rel="Chapter" href="Proofnode.html">
<link title="Proofrule" rel="Chapter" href="Proofrule.html">
<link title="Proof" rel="Chapter" href="Proof.html">
<link title="Prover" rel="Chapter" href="Prover.html">
<link title="Seqtactics" rel="Chapter" href="Seqtactics.html">
<link title="Abdrule" rel="Chapter" href="Abdrule.html">
<link title="Abducer" rel="Chapter" href="Abducer.html">
<link title="Sl_term" rel="Chapter" href="Sl_term.html">
<link title="Sl_subst" rel="Chapter" href="Sl_subst.html">
<link title="Sl_unifier" rel="Chapter" href="Sl_unifier.html">
<link title="Sl_tpair" rel="Chapter" href="Sl_tpair.html">
<link title="Sl_uf" rel="Chapter" href="Sl_uf.html">
<link title="Sl_rho" rel="Chapter" href="Sl_rho.html">
<link title="Sl_deqs" rel="Chapter" href="Sl_deqs.html">
<link title="Sl_pto" rel="Chapter" href="Sl_pto.html">
<link title="Sl_ptos" rel="Chapter" href="Sl_ptos.html">
<link title="Sl_pred" rel="Chapter" href="Sl_pred.html">
<link title="Sl_tpred" rel="Chapter" href="Sl_tpred.html">
<link title="Sl_tpreds" rel="Chapter" href="Sl_tpreds.html">
<link title="Sl_heap" rel="Chapter" href="Sl_heap.html">
<link title="Sl_heap_rho" rel="Chapter" href="Sl_heap_rho.html">
<link title="Sl_form" rel="Chapter" href="Sl_form.html">
<link title="Sl_form_rho" rel="Chapter" href="Sl_form_rho.html">
<link title="Sl_seq" rel="Chapter" href="Sl_seq.html">
<link title="Sl_indrule" rel="Chapter" href="Sl_indrule.html">
<link title="Tl_form" rel="Chapter" href="Tl_form.html">
<link title="Tl_form_ltl" rel="Chapter" href="Tl_form_ltl.html"><title>Index of values</title>
</head>
<body>
<div class="navbar">&nbsp;<a class="up" href="index.html" title="Index">Up</a>
&nbsp;</div>
<h1>Index of values</h1>
<table>
<tr><td align="left"><br>A</td></tr>
<tr><td><a href="Tl_form.Form.html#VALa_step">a_step</a> [<a href="Tl_form.Form.html">Tl_form.Form</a>]</td>
<td></td></tr>
<tr><td><a href="Sl_rho.html#VALadd">add</a> [<a href="Sl_rho.html">Sl_rho</a>]</td>
<td></td></tr>
<tr><td><a href="Sl_uf.html#VALadd">add</a> [<a href="Sl_uf.html">Sl_uf</a>]</td>
<td></td></tr>
<tr><td><a href="Hashset.S.html#VALadd">add</a> [<a href="Hashset.S.html">Hashset.S</a>]</td>
<td></td></tr>
<tr><td><a href="Sigs.PROOF.html#VALadd_axiom">add_axiom</a> [<a href="Sigs.PROOF.html">Sigs.PROOF</a>]</td>
<td></td></tr>
<tr><td><a href="Sigs.PROOF.html#VALadd_backlink">add_backlink</a> [<a href="Sigs.PROOF.html">Sigs.PROOF</a>]</td>
<td></td></tr>
<tr><td><a href="Sl_heap_rho.html#VALadd_deq">add_deq</a> [<a href="Sl_heap_rho.html">Sl_heap_rho</a>]</td>
<td></td></tr>
<tr><td><a href="Sl_heap.html#VALadd_deq">add_deq</a> [<a href="Sl_heap.html">Sl_heap</a>]</td>
<td></td></tr>
<tr><td><a href="Sl_heap_rho.html#VALadd_eq">add_eq</a> [<a href="Sl_heap_rho.html">Sl_heap_rho</a>]</td>
<td></td></tr>
<tr><td><a href="Sl_heap.html#VALadd_eq">add_eq</a> [<a href="Sl_heap.html">Sl_heap</a>]</td>
<td></td></tr>
<tr><td><a href="Sl_heap_rho.html#VALadd_ind">add_ind</a> [<a href="Sl_heap_rho.html">Sl_heap_rho</a>]</td>
<td></td></tr>
<tr><td><a href="Sl_heap.html#VALadd_ind">add_ind</a> [<a href="Sl_heap.html">Sl_heap</a>]</td>
<td></td></tr>
<tr><td><a href="Sigs.PROOF.html#VALadd_inf">add_inf</a> [<a href="Sigs.PROOF.html">Sigs.PROOF</a>]</td>
<td></td></tr>
<tr><td><a href="Sl_heap_rho.html#VALadd_pto">add_pto</a> [<a href="Sl_heap_rho.html">Sl_heap_rho</a>]</td>
<td></td></tr>
<tr><td><a href="Sl_heap.html#VALadd_pto">add_pto</a> [<a href="Sl_heap.html">Sl_heap</a>]</td>
<td></td></tr>
<tr><td><a href="Sl_rho.html#VALall_members_of">all_members_of</a> [<a href="Sl_rho.html">Sl_rho</a>]</td>
<td><div class="info">
<code class="code">all_members_of eqs eqs'</code> returns true iff all variables in <code class="code">rho</code> are also
    in <code class="code">rho'</code>
</div>
</td></tr>
<tr><td><a href="Sl_uf.html#VALall_members_of">all_members_of</a> [<a href="Sl_uf.html">Sl_uf</a>]</td>
<td><div class="info">
<code class="code">all_members_of eqs eqs'</code> returns true iff all equalities in <code class="code">eqs</code> are also
    in <code class="code">eqs'</code>
</div>
</td></tr>
<tr><td><a href="Sigs.PROOFRULE.html#VALall_nodes">all_nodes</a> [<a href="Sigs.PROOFRULE.html">Sigs.PROOFRULE</a>]</td>
<td><div class="info">
Ready-made selection functions doing the obvious.
</div>
</td></tr>
<tr><td><a href="Sl_heap_rho.html#VALall_subheaps">all_subheaps</a> [<a href="Sl_heap_rho.html">Sl_heap_rho</a>]</td>
<td><div class="info">
<code class="code">all_subheaps h</code> returns a list of all the subheaps of <code class="code">h</code>.
</div>
</td></tr>
<tr><td><a href="Sl_heap.html#VALall_subheaps">all_subheaps</a> [<a href="Sl_heap.html">Sl_heap</a>]</td>
<td><div class="info">
<code class="code">all_subheaps h</code> returns a list of all the subheaps of <code class="code">h</code>.
</div>
</td></tr>
<tr><td><a href="Sigs.PROOFRULE.html#VALancestor_nodes">ancestor_nodes</a> [<a href="Sigs.PROOFRULE.html">Sigs.PROOFRULE</a>]</td>
<td></td></tr>
<tr><td><a href="Blist.html#VALappend">append</a> [<a href="Blist.html">Blist</a>]</td>
<td><div class="info">
Catenate two ts.
</div>
</td></tr>
<tr><td><a href="Sl_tpred.html#VALargs">args</a> [<a href="Sl_tpred.html">Sl_tpred</a>]</td>
<td></td></tr>
<tr><td><a href="Sl_pred.html#VALargs">args</a> [<a href="Sl_pred.html">Sl_pred</a>]</td>
<td></td></tr>
<tr><td><a href="Sl_indrule.html#VALarity">arity</a> [<a href="Sl_indrule.html">Sl_indrule</a>]</td>
<td></td></tr>
<tr><td><a href="Sl_tpred.html#VALarity">arity</a> [<a href="Sl_tpred.html">Sl_tpred</a>]</td>
<td></td></tr>
<tr><td><a href="Sl_pred.html#VALarity">arity</a> [<a href="Sl_pred.html">Sl_pred</a>]</td>
<td></td></tr>
<tr><td><a href="Blist.html#VALassoc">assoc</a> [<a href="Blist.html">Blist</a>]</td>
<td><div class="info">
<code class="code">assoc a l</code> returns the value associated with key <code class="code">a</code> in the t of
   pairs <code class="code">l</code>.
</div>
</td></tr>
<tr><td><a href="Blist.html#VALassq">assq</a> [<a href="Blist.html">Blist</a>]</td>
<td><div class="info">
Same as <code class="code">List.assoc</code>, but uses physical equality instead of structural
   equality to compare keys.
</div>
</td></tr>
<tr><td><a href="Sigs.ABDRULE.html#VALattempt">attempt</a> [<a href="Sigs.ABDRULE.html">Sigs.ABDRULE</a>]</td>
<td></td></tr>
<tr><td><a href="Sigs.PROOFRULE.html#VALattempt">attempt</a> [<a href="Sigs.PROOFRULE.html">Sigs.PROOFRULE</a>]</td>
<td><div class="info">
Try a rule and if it fails act as <code class="code">identity</code>.
</div>
</td></tr>
<tr><td><a href="Sigs.SEQTACTICS.html#VALattempt">attempt</a> [<a href="Sigs.SEQTACTICS.html">Sigs.SEQTACTICS</a>]</td>
<td></td></tr>
<tr><td><a href="Sl_term.SubstSig.html#VALavoid">avoid</a> [<a href="Sl_term.SubstSig.html">Sl_term.SubstSig</a>]</td>
<td><div class="info">
<code class="code">avoid vars subvars</code> 
      returns a substitution that takes all variables in <code class="code">subvars</code> to  
      variables fresh in <code class="code">vars U subvars</code>, respecting existential   
      quantification / free variables.
</div>
</td></tr>
<tr><td><a href="Sl_term.SubstSig.html#VALavoids_replacing_check">avoids_replacing_check</a> [<a href="Sl_term.SubstSig.html">Sl_term.SubstSig</a>]</td>
<td><div class="info">
A substitution check which prevents replacements of variables within the
      given set of terms
</div>
</td></tr>
<tr><td align="left"><br>B</td></tr>
<tr><td><a href="Sl_term.UnifierSig.html#VALbacktrack">backtrack</a> [<a href="Sl_term.UnifierSig.html">Sl_term.UnifierSig</a>]</td>
<td><div class="info">
Wrap a unifier into a function that always backtracks, collecting all 
        states such that <code class="code">cont state</code> is not <code class="code">None</code> and returning that list.
</div>
</td></tr>
<tr><td><a href="Sl_term.SubstSig.html#VALbasic_lhs_down_check">basic_lhs_down_check</a> [<a href="Sl_term.SubstSig.html">Sl_term.SubstSig</a>]</td>
<td><div class="info">
When used as <code class="code">subst_check</code> in the call <code class="code">Sl_heap.unify subst_check f f'</code>, 
      ensures that the generated substitution, when applied to <code class="code">f</code>, produces a
      formula which is subsumed by <code class="code">f'</code>
</div>
</td></tr>
<tr><td><a href="Sl_term.UnifierSig.html#VALbasic_lhs_down_verifier">basic_lhs_down_verifier</a> [<a href="Sl_term.UnifierSig.html">Sl_term.UnifierSig</a>]</td>
<td><div class="info">
A continutation generated from the <code class="code">basic_lhs_down_check</code> substitution 
        check
</div>
</td></tr>
<tr><td><a href="Sigs.ABDUCER.html#VALbfs">bfs</a> [<a href="Sigs.ABDUCER.html">Sigs.ABDUCER</a>]</td>
<td></td></tr>
<tr><td><a href="Blist.html#VALbind">bind</a> [<a href="Blist.html">Blist</a>]</td>
<td></td></tr>
<tr><td><a href="Sl_rho.html#VALbindings">bindings</a> [<a href="Sl_rho.html">Sl_rho</a>]</td>
<td><div class="info">
Return mapping as a list of pairs of terms and values
	 Additional guarantees: Pairs are ordered lexicographically, based on <code class="code">Sl_term.compare</code>.
</div>
</td></tr>
<tr><td><a href="Sl_uf.html#VALbindings">bindings</a> [<a href="Sl_uf.html">Sl_uf</a>]</td>
<td><div class="info">
Return mapping as a list of pairs, where pair members are ordered by
</div>
</td></tr>
<tr><td><a href="Sl_indrule.html#VALbody">body</a> [<a href="Sl_indrule.html">Sl_indrule</a>]</td>
<td></td></tr>
<tr><td><a href="Soundcheck.html#VALbuild_proof">build_proof</a> [<a href="Soundcheck.html">Soundcheck</a>]</td>
<td></td></tr>
<tr><td><a href="Blist.html#VALbut_last">but_last</a> [<a href="Blist.html">Blist</a>]</td>
<td><div class="info">
Return a list containing all elements apart from the last one.
</div>
</td></tr>
<tr><td align="left"><br>C</td></tr>
<tr><td><a href="Hashset.S.html#VALcardinal">cardinal</a> [<a href="Hashset.S.html">Hashset.S</a>]</td>
<td></td></tr>
<tr><td><a href="Blist.html#VALcartesian_hemi_square">cartesian_hemi_square</a> [<a href="Blist.html">Blist</a>]</td>
<td><div class="info">
Return a list of all pairs out of elements of a list, but without including
symmetric pairs.
</div>
</td></tr>
<tr><td><a href="Blist.html#VALcartesian_product">cartesian_product</a> [<a href="Blist.html">Blist</a>]</td>
<td></td></tr>
<tr><td><a href="Sigs.PROOF.html#VALcheck">check</a> [<a href="Sigs.PROOF.html">Sigs.PROOF</a>]</td>
<td><div class="info">
Check soundness.
</div>
</td></tr>
<tr><td><a href="Soundcheck.html#VALcheck_proof">check_proof</a> [<a href="Soundcheck.html">Soundcheck</a>]</td>
<td><div class="info">
Validate, minimise, check soundness of proof/graph and memoise.
</div>
</td></tr>
<tr><td><a href="Sigs.ABDRULE.html#VALchoice">choice</a> [<a href="Sigs.ABDRULE.html">Sigs.ABDRULE</a>]</td>
<td></td></tr>
<tr><td><a href="Sigs.PROOFRULE.html#VALchoice">choice</a> [<a href="Sigs.PROOFRULE.html">Sigs.PROOFRULE</a>]</td>
<td><div class="info">
Apply a list of rules on current subgoal and return all applications.
</div>
</td></tr>
<tr><td><a href="Sigs.SEQTACTICS.html#VALchoice">choice</a> [<a href="Sigs.SEQTACTICS.html">Sigs.SEQTACTICS</a>]</td>
<td></td></tr>
<tr><td><a href="Blist.html#VALchoose">choose</a> [<a href="Blist.html">Blist</a>]</td>
<td><div class="info">
<code class="code">choose [[1;2;3]; [4;5]]</code> returns <code class="code">[[1;4];[1;5];[2;4];[2;5];[3;4];[3;5]]</code>.
</div>
</td></tr>
<tr><td><a href="Sl_heap_rho.html#VALclassical_unify">classical_unify</a> [<a href="Sl_heap_rho.html">Sl_heap_rho</a>]</td>
<td><div class="info">
Unify two heaps, by using <code class="code">unify_partial</code> for the pure (classical) part whilst
    using <code class="code">unify</code> for the spatial part.
</div>
</td></tr>
<tr><td><a href="Sl_heap.html#VALclassical_unify">classical_unify</a> [<a href="Sl_heap.html">Sl_heap</a>]</td>
<td><div class="info">
Unify two heaps, by using <code class="code">unify_partial</code> for the pure (classical) part whilst
    using <code class="code">unify</code> for the spatial part.
</div>
</td></tr>
<tr><td><a href="Hashset.S.html#VALclear">clear</a> [<a href="Hashset.S.html">Hashset.S</a>]</td>
<td></td></tr>
<tr><td><a href="Sl_heap_rho.html#VALcombine">combine</a> [<a href="Sl_heap_rho.html">Sl_heap_rho</a>]</td>
<td></td></tr>
<tr><td><a href="Sl_heap.html#VALcombine">combine</a> [<a href="Sl_heap.html">Sl_heap</a>]</td>
<td></td></tr>
<tr><td><a href="Blist.html#VALcombine">combine</a> [<a href="Blist.html">Blist</a>]</td>
<td><div class="info">
Transform a pair of ts into a t of pairs:
   <code class="code">combine [a1; ...; an] [b1; ...; bn]</code> is
   <code class="code">[(a1,b1); ...; (an,bn)]</code>.
</div>
</td></tr>
<tr><td><a href="Sigs.PROOFRULE.html#VALcombine_axioms">combine_axioms</a> [<a href="Sigs.PROOFRULE.html">Sigs.PROOFRULE</a>]</td>
<td></td></tr>
<tr><td><a href="Sl_term.SubstSig.html#VALcombine_checks">combine_checks</a> [<a href="Sl_term.SubstSig.html">Sl_term.SubstSig</a>]</td>
<td><div class="info">
Combinator which takes a list of substitution pair check functions and
      combines them into a single check function
</div>
</td></tr>
<tr><td><a href="Sl_term.UnifierSig.html#VALcombine_state_checks">combine_state_checks</a> [<a href="Sl_term.UnifierSig.html">Sl_term.UnifierSig</a>]</td>
<td><div class="info">
Combinator which takes a list of unifier state check functions and
        combines them into a single check function
</div>
</td></tr>
<tr><td><a href="Blist.html#VALcombs">combs</a> [<a href="Blist.html">Blist</a>]</td>
<td><div class="info">
<code class="code">combs n l</code> returns all combinations of <code class="code">n</code> elements from <code class="code">l</code>.
</div>
</td></tr>
<tr><td><a href="Tl_form_ltl.Form.html#VALcompare">compare</a> [<a href="Tl_form_ltl.Form.html">Tl_form_ltl.Form</a>]</td>
<td></td></tr>
<tr><td><a href="Tl_form.Form.html#VALcompare">compare</a> [<a href="Tl_form.Form.html">Tl_form.Form</a>]</td>
<td></td></tr>
<tr><td><a href="Sigs.ABDRULE.html#VALcompose">compose</a> [<a href="Sigs.ABDRULE.html">Sigs.ABDRULE</a>]</td>
<td></td></tr>
<tr><td><a href="Sigs.PROOFRULE.html#VALcompose">compose</a> [<a href="Sigs.PROOFRULE.html">Sigs.PROOFRULE</a>]</td>
<td><div class="info">
Apply the list of rules in the second argument in a pairwise fashion to 
      the premises generated by applying the first rule
</div>
</td></tr>
<tr><td><a href="Sigs.SEQTACTICS.html#VALcompose">compose</a> [<a href="Sigs.SEQTACTICS.html">Sigs.SEQTACTICS</a>]</td>
<td></td></tr>
<tr><td><a href="Sigs.PROOFRULE.html#VALcompose_pairwise">compose_pairwise</a> [<a href="Sigs.PROOFRULE.html">Sigs.PROOFRULE</a>]</td>
<td></td></tr>
<tr><td><a href="Sl_heap_rho.html#VALcompute_frame">compute_frame</a> [<a href="Sl_heap_rho.html">Sl_heap_rho</a>]</td>
<td><div class="info">
<code class="code">compute_frame f f'</code> computes the portion of <code class="code">f'</code> left over (the 'frame') 
    after subtracting all the atomic formulae in the specification <code class="code">f</code>.
</div>
</td></tr>
<tr><td><a href="Sl_heap.html#VALcompute_frame">compute_frame</a> [<a href="Sl_heap.html">Sl_heap</a>]</td>
<td><div class="info">
<code class="code">compute_frame f f'</code> computes the portion of <code class="code">f'</code> left over (the 'frame') 
    after subtracting all the atomic formulae in the specification <code class="code">f</code>.
</div>
</td></tr>
<tr><td><a href="Blist.html#VALconcat">concat</a> [<a href="Blist.html">Blist</a>]</td>
<td><div class="info">
Concatenate a t of ts.
</div>
</td></tr>
<tr><td><a href="Sigs.PROOFRULE.html#VALconditional">conditional</a> [<a href="Sigs.PROOFRULE.html">Sigs.PROOFRULE</a>]</td>
<td></td></tr>
<tr><td><a href="Blist.html#VALcons">cons</a> [<a href="Blist.html">Blist</a>]</td>
<td><div class="info">
Equivalent to <code class="code">::</code>.
</div>
</td></tr>
<tr><td><a href="Sl_indrule.html#VALconstructively_valued">constructively_valued</a> [<a href="Sl_indrule.html">Sl_indrule</a>]</td>
<td><div class="info">
<code class="code">constructively_valued r</code> returns true iff the body of <code class="code">r</code> is 
    constructively valued (see <code class="code">Sl_heap</code>).
</div>
</td></tr>
<tr><td><a href="Sl_heap.html#VALconstructively_valued">constructively_valued</a> [<a href="Sl_heap.html">Sl_heap</a>]</td>
<td><div class="info">
<code class="code">constructively_valued h</code> returns true if all variables in <code class="code">h</code> are
    c.valued.
</div>
</td></tr>
<tr><td><a href="Hashset.S.html#VALcopy">copy</a> [<a href="Hashset.S.html">Hashset.S</a>]</td>
<td></td></tr>
<tr><td><a href="Hashset.S.html#VALcreate">create</a> [<a href="Hashset.S.html">Hashset.S</a>]</td>
<td></td></tr>
<tr><td align="left"><br>D</td></tr>
<tr><td><a href="Blist.html#VALdecons">decons</a> [<a href="Blist.html">Blist</a>]</td>
<td><div class="info">
Destruct a non-empty list.
</div>
</td></tr>
<tr><td><a href="Sl_heap_rho.html#VALdel_deq">del_deq</a> [<a href="Sl_heap_rho.html">Sl_heap_rho</a>]</td>
<td></td></tr>
<tr><td><a href="Sl_heap.html#VALdel_deq">del_deq</a> [<a href="Sl_heap.html">Sl_heap</a>]</td>
<td></td></tr>
<tr><td><a href="Blist.html#VALdel_first">del_first</a> [<a href="Blist.html">Blist</a>]</td>
<td><div class="info">
Delete first element satisfying a given predicate.
</div>
</td></tr>
<tr><td><a href="Sl_heap_rho.html#VALdel_ind">del_ind</a> [<a href="Sl_heap_rho.html">Sl_heap_rho</a>]</td>
<td></td></tr>
<tr><td><a href="Sl_heap.html#VALdel_ind">del_ind</a> [<a href="Sl_heap.html">Sl_heap</a>]</td>
<td></td></tr>
<tr><td><a href="Sl_heap_rho.html#VALdel_pto">del_pto</a> [<a href="Sl_heap_rho.html">Sl_heap_rho</a>]</td>
<td></td></tr>
<tr><td><a href="Sl_heap.html#VALdel_pto">del_pto</a> [<a href="Sl_heap.html">Sl_heap</a>]</td>
<td></td></tr>
<tr><td><a href="Sl_indrule.html#VALdest">dest</a> [<a href="Sl_indrule.html">Sl_indrule</a>]</td>
<td></td></tr>
<tr><td><a href="Sl_seq.html#VALdest">dest</a> [<a href="Sl_seq.html">Sl_seq</a>]</td>
<td><div class="info">
If both LHS and RHS are symbolic heaps then return them else raise
    <code class="code">Sl_form.Not_symheap</code>.
</div>
</td></tr>
<tr><td><a href="Sl_form_rho.html#VALdest">dest</a> [<a href="Sl_form_rho.html">Sl_form_rho</a>]</td>
<td><div class="info">
Return the single disjunct, if there is exactly one, else raise <code class="code">Not_symheap</code>.
</div>
</td></tr>
<tr><td><a href="Sl_form.html#VALdest">dest</a> [<a href="Sl_form.html">Sl_form</a>]</td>
<td><div class="info">
Return the single disjunct, if there is exactly one, else raise <code class="code">Not_symheap</code>.
</div>
</td></tr>
<tr><td><a href="Sl_heap_rho.html#VALdest">dest</a> [<a href="Sl_heap_rho.html">Sl_heap_rho</a>]</td>
<td></td></tr>
<tr><td><a href="Sl_heap.html#VALdest">dest</a> [<a href="Sl_heap.html">Sl_heap</a>]</td>
<td></td></tr>
<tr><td><a href="Sigs.NODE.html#VALdest">dest</a> [<a href="Sigs.NODE.html">Sigs.NODE</a>]</td>
<td><div class="info">
<code class="code">dest n</code> returns (sequent, description).
</div>
</td></tr>
<tr><td><a href="Tl_form.Form.html#VALdest_af">dest_af</a> [<a href="Tl_form.Form.html">Tl_form.Form</a>]</td>
<td></td></tr>
<tr><td><a href="Tl_form.Form.html#VALdest_ag">dest_ag</a> [<a href="Tl_form.Form.html">Tl_form.Form</a>]</td>
<td></td></tr>
<tr><td><a href="Tl_form_ltl.Form.html#VALdest_and">dest_and</a> [<a href="Tl_form_ltl.Form.html">Tl_form_ltl.Form</a>]</td>
<td></td></tr>
<tr><td><a href="Tl_form.Form.html#VALdest_and">dest_and</a> [<a href="Tl_form.Form.html">Tl_form.Form</a>]</td>
<td></td></tr>
<tr><td><a href="Tl_form_ltl.Form.html#VALdest_atom">dest_atom</a> [<a href="Tl_form_ltl.Form.html">Tl_form_ltl.Form</a>]</td>
<td></td></tr>
<tr><td><a href="Tl_form.Form.html#VALdest_atom">dest_atom</a> [<a href="Tl_form.Form.html">Tl_form.Form</a>]</td>
<td></td></tr>
<tr><td><a href="Sigs.NODE.html#VALdest_backlink">dest_backlink</a> [<a href="Sigs.NODE.html">Sigs.NODE</a>]</td>
<td><div class="info">
<code class="code">dest_backlink n</code> destroys a back-link node <code class="code">n</code>, otherwise raises <code class="code">Invalid_arg</code>.
</div>
</td></tr>
<tr><td><a href="Tl_form.Form.html#VALdest_box">dest_box</a> [<a href="Tl_form.Form.html">Tl_form.Form</a>]</td>
<td></td></tr>
<tr><td><a href="Tl_form.Form.html#VALdest_circle">dest_circle</a> [<a href="Tl_form.Form.html">Tl_form.Form</a>]</td>
<td></td></tr>
<tr><td><a href="Tl_form.Form.html#VALdest_diamond">dest_diamond</a> [<a href="Tl_form.Form.html">Tl_form.Form</a>]</td>
<td></td></tr>
<tr><td><a href="Tl_form.Form.html#VALdest_ef">dest_ef</a> [<a href="Tl_form.Form.html">Tl_form.Form</a>]</td>
<td></td></tr>
<tr><td><a href="Tl_form.Form.html#VALdest_eg">dest_eg</a> [<a href="Tl_form.Form.html">Tl_form.Form</a>]</td>
<td></td></tr>
<tr><td><a href="Tl_form_ltl.Form.html#VALdest_f">dest_f</a> [<a href="Tl_form_ltl.Form.html">Tl_form_ltl.Form</a>]</td>
<td></td></tr>
<tr><td><a href="Tl_form_ltl.Form.html#VALdest_g">dest_g</a> [<a href="Tl_form_ltl.Form.html">Tl_form_ltl.Form</a>]</td>
<td></td></tr>
<tr><td><a href="Sigs.NODE.html#VALdest_inf">dest_inf</a> [<a href="Sigs.NODE.html">Sigs.NODE</a>]</td>
<td><div class="info">
<code class="code">dest_inf n</code> destroys an inference node <code class="code">n</code>, otherwise raises <code class="code">Invalid_arg</code>.
</div>
</td></tr>
<tr><td><a href="Tl_form_ltl.Form.html#VALdest_next">dest_next</a> [<a href="Tl_form_ltl.Form.html">Tl_form_ltl.Form</a>]</td>
<td></td></tr>
<tr><td><a href="Tl_form_ltl.Form.html#VALdest_or">dest_or</a> [<a href="Tl_form_ltl.Form.html">Tl_form_ltl.Form</a>]</td>
<td></td></tr>
<tr><td><a href="Tl_form.Form.html#VALdest_or">dest_or</a> [<a href="Tl_form.Form.html">Tl_form.Form</a>]</td>
<td></td></tr>
<tr><td><a href="Sl_heap_rho.html#VALdiff">diff</a> [<a href="Sl_heap_rho.html">Sl_heap_rho</a>]</td>
<td></td></tr>
<tr><td><a href="Sl_heap.html#VALdiff">diff</a> [<a href="Sl_heap.html">Sl_heap</a>]</td>
<td></td></tr>
<tr><td><a href="Sl_rho.html#VALdiff">diff</a> [<a href="Sl_rho.html">Sl_rho</a>]</td>
<td><div class="info">
<code class="code">diff rho rho'</code> returns the structure given by removing all variables in
    <code class="code">rho'</code> from <code class="code">rho</code>
</div>
</td></tr>
<tr><td><a href="Sl_uf.html#VALdiff">diff</a> [<a href="Sl_uf.html">Sl_uf</a>]</td>
<td><div class="info">
<code class="code">diff eqs eqs'</code> returns the structure given by removing all equalities in
    <code class="code">eqs'</code> from <code class="code">eqs</code>
</div>
</td></tr>
<tr><td><a href="Sl_heap_rho.html#VALdisequates">disequates</a> [<a href="Sl_heap_rho.html">Sl_heap_rho</a>]</td>
<td><div class="info">
Does a symbolic heap entail the disequality of two terms?
</div>
</td></tr>
<tr><td><a href="Sl_heap.html#VALdisequates">disequates</a> [<a href="Sl_heap.html">Sl_heap</a>]</td>
<td><div class="info">
Does a symbolic heap entail the disequality of two terms?
</div>
</td></tr>
<tr><td><a href="Sl_form_rho.html#VALdisj">disj</a> [<a href="Sl_form_rho.html">Sl_form_rho</a>]</td>
<td><div class="info">
Or two formulas (list-append).
</div>
</td></tr>
<tr><td><a href="Sl_form.html#VALdisj">disj</a> [<a href="Sl_form.html">Sl_form</a>]</td>
<td><div class="info">
Or two formulas (list-append).
</div>
</td></tr>
<tr><td><a href="Blist.html#VALdrop">drop</a> [<a href="Blist.html">Blist</a>]</td>
<td><div class="info">
<code class="code">drop n l</code> returns the suffix of <code class="code">l</code> after skipping <code class="code">n</code> elements.
</div>
</td></tr>
<tr><td align="left"><br>E</td></tr>
<tr><td><a href="Tl_form.Form.html#VALe_step">e_step</a> [<a href="Tl_form.Form.html">Tl_form.Form</a>]</td>
<td></td></tr>
<tr><td><a href="Sl_form_rho.html#VALempty">empty</a> [<a href="Sl_form_rho.html">Sl_form_rho</a>]</td>
<td><div class="info">
The formula <code class="code">emp</code>.
</div>
</td></tr>
<tr><td><a href="Sl_form.html#VALempty">empty</a> [<a href="Sl_form.html">Sl_form</a>]</td>
<td><div class="info">
The formula <code class="code">emp</code>.
</div>
</td></tr>
<tr><td><a href="Sl_heap_rho.html#VALempty">empty</a> [<a href="Sl_heap_rho.html">Sl_heap_rho</a>]</td>
<td></td></tr>
<tr><td><a href="Sl_heap.html#VALempty">empty</a> [<a href="Sl_heap.html">Sl_heap</a>]</td>
<td></td></tr>
<tr><td><a href="Sl_rho.html#VALempty">empty</a> [<a href="Sl_rho.html">Sl_rho</a>]</td>
<td></td></tr>
<tr><td><a href="Sl_uf.html#VALempty">empty</a> [<a href="Sl_uf.html">Sl_uf</a>]</td>
<td></td></tr>
<tr><td><a href="Sl_term.SubstSig.html#VALempty">empty</a> [<a href="Sl_term.SubstSig.html">Sl_term.SubstSig</a>]</td>
<td><div class="info">
The empty substitution, which has no effect when applied.
</div>
</td></tr>
<tr><td><a href="Blist.html#VALempty">empty</a> [<a href="Blist.html">Blist</a>]</td>
<td><div class="info">
The empty list constant.
</div>
</td></tr>
<tr><td><a href="Sl_term.UnifierSig.html#VALempty_state">empty_state</a> [<a href="Sl_term.UnifierSig.html">Sl_term.UnifierSig</a>]</td>
<td><div class="info">
The unifier state consisting of the empty substitution and the empty set of
        tag pairs
</div>
</td></tr>
<tr><td><a href="Tl_form_ltl.Form.html#VALequal">equal</a> [<a href="Tl_form_ltl.Form.html">Tl_form_ltl.Form</a>]</td>
<td></td></tr>
<tr><td><a href="Tl_form.Form.html#VALequal">equal</a> [<a href="Tl_form.Form.html">Tl_form.Form</a>]</td>
<td></td></tr>
<tr><td><a href="Sl_heap_rho.html#VALequal">equal</a> [<a href="Sl_heap_rho.html">Sl_heap_rho</a>]</td>
<td><div class="info">
Checks whether two symbolic heaps are equal.
</div>
</td></tr>
<tr><td><a href="Sl_heap.html#VALequal">equal</a> [<a href="Sl_heap.html">Sl_heap</a>]</td>
<td><div class="info">
Checks whether two symbolic heaps are equal.
</div>
</td></tr>
<tr><td><a href="Sigs.SEQUENT.html#VALequal">equal</a> [<a href="Sigs.SEQUENT.html">Sigs.SEQUENT</a>]</td>
<td><div class="info">
"Syntactic" equality.
</div>
</td></tr>
<tr><td><a href="Hashset.HashedType.html#VALequal">equal</a> [<a href="Hashset.HashedType.html">Hashset.HashedType</a>]</td>
<td><div class="info">
The equality predicate used to compare elements.
</div>
</td></tr>
<tr><td><a href="Blist.html#VALequal">equal</a> [<a href="Blist.html">Blist</a>]</td>
<td><div class="info">
<code class="code">equal eq l l'</code> computes pointwise equality between <code class="code">l</code> and <code class="code">l'</code> assuming
<code class="code">eq</code> computes equality between elements.
</div>
</td></tr>
<tr><td><a href="Tl_form_ltl.Form.html#VALequal_upto_tags">equal_upto_tags</a> [<a href="Tl_form_ltl.Form.html">Tl_form_ltl.Form</a>]</td>
<td></td></tr>
<tr><td><a href="Tl_form.Form.html#VALequal_upto_tags">equal_upto_tags</a> [<a href="Tl_form.Form.html">Tl_form.Form</a>]</td>
<td></td></tr>
<tr><td><a href="Sl_seq.html#VALequal_upto_tags">equal_upto_tags</a> [<a href="Sl_seq.html">Sl_seq</a>]</td>
<td><div class="info">
Like <code class="code">equal</code> but ignoring LHS tags as well as RHS ones.
</div>
</td></tr>
<tr><td><a href="Sl_form_rho.html#VALequal_upto_tags">equal_upto_tags</a> [<a href="Sl_form_rho.html">Sl_form_rho</a>]</td>
<td><div class="info">
Whilst <code class="code">equal</code> demands syntactic equality including tags, this version 
    ignores tag assignment.
</div>
</td></tr>
<tr><td><a href="Sl_form.html#VALequal_upto_tags">equal_upto_tags</a> [<a href="Sl_form.html">Sl_form</a>]</td>
<td><div class="info">
Whilst <code class="code">equal</code> demands syntactic equality including tags, this version 
    ignores tag assignment.
</div>
</td></tr>
<tr><td><a href="Sl_heap_rho.html#VALequal_upto_tags">equal_upto_tags</a> [<a href="Sl_heap_rho.html">Sl_heap_rho</a>]</td>
<td><div class="info">
Like <code class="code">equal</code> but ignoring tag assignment.
</div>
</td></tr>
<tr><td><a href="Sl_heap.html#VALequal_upto_tags">equal_upto_tags</a> [<a href="Sl_heap.html">Sl_heap</a>]</td>
<td><div class="info">
Like <code class="code">equal</code> but ignoring tag assignment.
</div>
</td></tr>
<tr><td><a href="Sl_tpreds.html#VALequal_upto_tags">equal_upto_tags</a> [<a href="Sl_tpreds.html">Sl_tpreds</a>]</td>
<td><div class="info">
Test whether the two arguments are the equal ignoring tags.
</div>
</td></tr>
<tr><td><a href="Sigs.SEQUENT.html#VALequal_upto_tags">equal_upto_tags</a> [<a href="Sigs.SEQUENT.html">Sigs.SEQUENT</a>]</td>
<td><div class="info">
As <code class="code">equal</code> but ignoring tags.
</div>
</td></tr>
<tr><td><a href="Sl_heap_rho.html#VALequates">equates</a> [<a href="Sl_heap_rho.html">Sl_heap_rho</a>]</td>
<td><div class="info">
Does a symbolic heap entail the equality of two terms?
</div>
</td></tr>
<tr><td><a href="Sl_heap.html#VALequates">equates</a> [<a href="Sl_heap.html">Sl_heap</a>]</td>
<td><div class="info">
Does a symbolic heap entail the equality of two terms?
</div>
</td></tr>
<tr><td><a href="Sl_rho.html#VALequates">equates</a> [<a href="Sl_rho.html">Sl_rho</a>]</td>
<td><div class="info">
Does a stack struct holds a term with a val?
</div>
</td></tr>
<tr><td><a href="Sl_uf.html#VALequates">equates</a> [<a href="Sl_uf.html">Sl_uf</a>]</td>
<td><div class="info">
Does a UF struct make two terms equal?
</div>
</td></tr>
<tr><td><a href="Hashset.S.html#VALexists">exists</a> [<a href="Hashset.S.html">Hashset.S</a>]</td>
<td></td></tr>
<tr><td><a href="Blist.html#VALexists">exists</a> [<a href="Blist.html">Blist</a>]</td>
<td><div class="info">
<code class="code">exists p [a1; ...; an]</code> checks if at least one element of
   the t satisfies the predicate <code class="code">p</code>.
</div>
</td></tr>
<tr><td><a href="Blist.html#VALexists2">exists2</a> [<a href="Blist.html">Blist</a>]</td>
<td><div class="info">
Same as <code class="code">List.exists</code>, but for a two-argument predicate.
</div>
</td></tr>
<tr><td><a href="Tl_form_ltl.Form.html#VALextract_checkable_slformula">extract_checkable_slformula</a> [<a href="Tl_form_ltl.Form.html">Tl_form_ltl.Form</a>]</td>
<td></td></tr>
<tr><td><a href="Tl_form.Form.html#VALextract_checkable_slformula">extract_checkable_slformula</a> [<a href="Tl_form.Form.html">Tl_form.Form</a>]</td>
<td></td></tr>
<tr><td align="left"><br>F</td></tr>
<tr><td><a href="Sigs.ABDRULE.html#VALfail">fail</a> [<a href="Sigs.ABDRULE.html">Sigs.ABDRULE</a>]</td>
<td></td></tr>
<tr><td><a href="Sigs.PROOFRULE.html#VALfail">fail</a> [<a href="Sigs.PROOFRULE.html">Sigs.PROOFRULE</a>]</td>
<td><div class="info">
The rule that always fails.
</div>
</td></tr>
<tr><td><a href="Blist.html#VALfast_sort">fast_sort</a> [<a href="Blist.html">Blist</a>]</td>
<td><div class="info">
Same as <code class="code">List.sort</code> or <code class="code">List.stable_sort</code>, whichever is faster
    on typical input.
</div>
</td></tr>
<tr><td><a href="Hashset.S.html#VALfilter">filter</a> [<a href="Hashset.S.html">Hashset.S</a>]</td>
<td></td></tr>
<tr><td><a href="Blist.html#VALfilter">filter</a> [<a href="Blist.html">Blist</a>]</td>
<td><div class="info">
<code class="code">filter p l</code> returns all the elements of the t <code class="code">l</code>
   that satisfy the predicate <code class="code">p</code>.
</div>
</td></tr>
<tr><td><a href="Sl_term.html#VALfilter_vars">filter_vars</a> [<a href="Sl_term.html">Sl_term</a>]</td>
<td><div class="info">
Remove <code class="code">nil</code> from a set of terms.
</div>
</td></tr>
<tr><td><a href="Sl_rho.html#VALfind">find</a> [<a href="Sl_rho.html">Sl_rho</a>]</td>
<td></td></tr>
<tr><td><a href="Sl_uf.html#VALfind">find</a> [<a href="Sl_uf.html">Sl_uf</a>]</td>
<td></td></tr>
<tr><td><a href="Sigs.PROOF.html#VALfind">find</a> [<a href="Sigs.PROOF.html">Sigs.PROOF</a>]</td>
<td></td></tr>
<tr><td><a href="Blist.html#VALfind">find</a> [<a href="Blist.html">Blist</a>]</td>
<td><div class="info">
<code class="code">find p l</code> returns the first element of the t <code class="code">l</code>
   that satisfies the predicate <code class="code">p</code>.
</div>
</td></tr>
<tr><td><a href="Blist.html#VALfind_all">find_all</a> [<a href="Blist.html">Blist</a>]</td>
<td><div class="info">
<code class="code">find_all</code> is another name for <code class="code">List.filter</code>.
</div>
</td></tr>
<tr><td><a href="Blist.html#VALfind_first">find_first</a> [<a href="Blist.html">Blist</a>]</td>
<td><div class="info">
<code class="code">find_first pred l</code> returns <code class="code">Some x</code> for the first <code class="code">x</code> in <code class="code">l</code> such that <code class="code">pred x = true</code>, or <code class="code">None</code>.
</div>
</td></tr>
<tr><td><a href="Blist.html#VALfind_index">find_index</a> [<a href="Blist.html">Blist</a>]</td>
<td><div class="info">
<code class="code">find_index pred l</code> returns the position of the first <code class="code">x</code> in <code class="code">l</code> such that <code class="code">pred x = true</code> or throws <code class="code">Not_found</code>.
</div>
</td></tr>
<tr><td><a href="Blist.html#VALfind_indexes">find_indexes</a> [<a href="Blist.html">Blist</a>]</td>
<td><div class="info">
<code class="code">find_indexes pred l</code> returns the list of positions of all <code class="code">x</code> in <code class="code">l</code> such that <code class="code">pred x = true</code>.
</div>
</td></tr>
<tr><td><a href="Sl_heap_rho.html#VALfind_lval">find_lval</a> [<a href="Sl_heap_rho.html">Sl_heap_rho</a>]</td>
<td><div class="info">
Find pto whose address is provably equal to given term.
</div>
</td></tr>
<tr><td><a href="Sl_heap.html#VALfind_lval">find_lval</a> [<a href="Sl_heap.html">Sl_heap</a>]</td>
<td><div class="info">
Find pto whose address is provably equal to given term.
</div>
</td></tr>
<tr><td><a href="Blist.html#VALfind_some">find_some</a> [<a href="Blist.html">Blist</a>]</td>
<td><div class="info">
Optimisation for finding and converting at the same time.
</div>
</td></tr>
<tr><td><a href="Sigs.ABDRULE.html#VALfirst">first</a> [<a href="Sigs.ABDRULE.html">Sigs.ABDRULE</a>]</td>
<td></td></tr>
<tr><td><a href="Sigs.PROOFRULE.html#VALfirst">first</a> [<a href="Sigs.PROOFRULE.html">Sigs.PROOFRULE</a>]</td>
<td><div class="info">
Apply a sequence of rules iteratively through <code class="code">compose</code>.
</div>
</td></tr>
<tr><td><a href="Sigs.SEQTACTICS.html#VALfirst">first</a> [<a href="Sigs.SEQTACTICS.html">Sigs.SEQTACTICS</a>]</td>
<td></td></tr>
<tr><td><a href="Sl_heap_rho.html#VALfixpoint">fixpoint</a> [<a href="Sl_heap_rho.html">Sl_heap_rho</a>]</td>
<td></td></tr>
<tr><td><a href="Sl_heap.html#VALfixpoint">fixpoint</a> [<a href="Sl_heap.html">Sl_heap</a>]</td>
<td></td></tr>
<tr><td><a href="Blist.html#VALflatten">flatten</a> [<a href="Blist.html">Blist</a>]</td>
<td><div class="info">
Same as <code class="code">concat</code>.
</div>
</td></tr>
<tr><td><a href="Sl_indrule.html#VALfold">fold</a> [<a href="Sl_indrule.html">Sl_indrule</a>]</td>
<td><div class="info">
<code class="code">fold r h</code> returns a list of pairs of substitutions over the formal parameters of 
    the rule <code class="code">r</code> such that its body, when one of these substitutions is applied,
    becomes a subformula of <code class="code">h</code>; and the result of removing that subformula from
    <code class="code">h</code>.
</div>
</td></tr>
<tr><td><a href="Sl_rho.html#VALfold">fold</a> [<a href="Sl_rho.html">Sl_rho</a>]</td>
<td></td></tr>
<tr><td><a href="Sl_uf.html#VALfold">fold</a> [<a href="Sl_uf.html">Sl_uf</a>]</td>
<td></td></tr>
<tr><td><a href="Hashset.S.html#VALfold">fold</a> [<a href="Hashset.S.html">Hashset.S</a>]</td>
<td></td></tr>
<tr><td><a href="Blist.html#VALfold_left">fold_left</a> [<a href="Blist.html">Blist</a>]</td>
<td><div class="info">
<code class="code">List.fold_left f a [b1; ...; bn]</code> is
   <code class="code">f (... (f (f a b1) b2) ...) bn</code>.
</div>
</td></tr>
<tr><td><a href="Blist.html#VALfold_left2">fold_left2</a> [<a href="Blist.html">Blist</a>]</td>
<td><div class="info">
<code class="code">List.fold_left2 f a [b1; ...; bn] [c1; ...; cn]</code> is
   <code class="code">f (... (f (f a b1 c1) b2 c2) ...) bn cn</code>.
</div>
</td></tr>
<tr><td><a href="Blist.html#VALfold_right">fold_right</a> [<a href="Blist.html">Blist</a>]</td>
<td><div class="info">
<code class="code">List.fold_right f [a1; ...; an] b</code> is
   <code class="code">f a1 (f a2 (... (f an b) ...))</code>.
</div>
</td></tr>
<tr><td><a href="Blist.html#VALfold_right2">fold_right2</a> [<a href="Blist.html">Blist</a>]</td>
<td><div class="info">
<code class="code">List.fold_right2 f [a1; ...; an] [b1; ...; bn] c</code> is
   <code class="code">f a1 b1 (f a2 b2 (... (f an bn c) ...))</code>.
</div>
</td></tr>
<tr><td><a href="Blist.html#VALfoldl">foldl</a> [<a href="Blist.html">Blist</a>]</td>
<td></td></tr>
<tr><td><a href="Blist.html#VALfoldr">foldr</a> [<a href="Blist.html">Blist</a>]</td>
<td></td></tr>
<tr><td><a href="Sl_rho.html#VALfor_all">for_all</a> [<a href="Sl_rho.html">Sl_rho</a>]</td>
<td></td></tr>
<tr><td><a href="Sl_uf.html#VALfor_all">for_all</a> [<a href="Sl_uf.html">Sl_uf</a>]</td>
<td></td></tr>
<tr><td><a href="Hashset.S.html#VALfor_all">for_all</a> [<a href="Hashset.S.html">Hashset.S</a>]</td>
<td></td></tr>
<tr><td><a href="Blist.html#VALfor_all">for_all</a> [<a href="Blist.html">Blist</a>]</td>
<td><div class="info">
<code class="code">for_all p [a1; ...; an]</code> checks if all elements of the t
   satisfy the predicate <code class="code">p</code>.
</div>
</td></tr>
<tr><td><a href="Blist.html#VALfor_all2">for_all2</a> [<a href="Blist.html">Blist</a>]</td>
<td><div class="info">
Same as <code class="code">List.for_all</code>, but for a two-argument predicate.
</div>
</td></tr>
<tr><td><a href="Sl_indrule.html#VALformals">formals</a> [<a href="Sl_indrule.html">Sl_indrule</a>]</td>
<td></td></tr>
<tr><td><a href="Sl_term.html#VALfresh_evar">fresh_evar</a> [<a href="Sl_term.html">Sl_term</a>]</td>
<td><div class="info">
<code class="code">fresh_evar s</code> returns an existentially quantified variable that is 
    fresh in <code class="code">s</code>.
</div>
</td></tr>
<tr><td><a href="Sl_term.html#VALfresh_evars">fresh_evars</a> [<a href="Sl_term.html">Sl_term</a>]</td>
<td><div class="info">
<code class="code">fresh_evars s n</code> returns a list of existentially quantified variables 
    of length <code class="code">n</code> all of which are fresh in <code class="code">s</code>.
</div>
</td></tr>
<tr><td><a href="Sl_term.html#VALfresh_fvar">fresh_fvar</a> [<a href="Sl_term.html">Sl_term</a>]</td>
<td><div class="info">
<code class="code">fresh_fvar s</code> returns a free variable that is fresh in <code class="code">s</code>.
</div>
</td></tr>
<tr><td><a href="Sl_term.html#VALfresh_fvars">fresh_fvars</a> [<a href="Sl_term.html">Sl_term</a>]</td>
<td><div class="info">
<code class="code">fresh_fvars s n</code> returns a list of free variables of length <code class="code">n</code> 
    all of which are fresh in <code class="code">s</code>.
</div>
</td></tr>
<tr><td><a href="Sigs.PROOF.html#VALfresh_idx">fresh_idx</a> [<a href="Sigs.PROOF.html">Sigs.PROOF</a>]</td>
<td></td></tr>
<tr><td><a href="Sigs.PROOF.html#VALfresh_idxs">fresh_idxs</a> [<a href="Sigs.PROOF.html">Sigs.PROOF</a>]</td>
<td></td></tr>
<tr><td><a href="Sl_indrule.html#VALfreshen">freshen</a> [<a href="Sl_indrule.html">Sl_indrule</a>]</td>
<td><div class="info">
Replace all variables in rule such that they are disjoint with the set 
    provided.
</div>
</td></tr>
<tr><td><a href="Sl_heap_rho.html#VALfreshen_tags">freshen_tags</a> [<a href="Sl_heap_rho.html">Sl_heap_rho</a>]</td>
<td><div class="info">
<code class="code">freshen_tags f g</code> will rename all tags in <code class="code">g</code> such that they are disjoint
    from those of <code class="code">f</code>.
</div>
</td></tr>
<tr><td><a href="Sl_heap.html#VALfreshen_tags">freshen_tags</a> [<a href="Sl_heap.html">Sl_heap</a>]</td>
<td><div class="info">
<code class="code">freshen_tags f g</code> will rename all tags in <code class="code">g</code> such that they are disjoint
    from those of <code class="code">f</code>.
</div>
</td></tr>
<tr><td><a href="Sl_tpreds.html#VALfreshen_tags">freshen_tags</a> [<a href="Sl_tpreds.html">Sl_tpreds</a>]</td>
<td><div class="info">
Rename tags in second argument so that they are disjoint to those in the first.
</div>
</td></tr>
<tr><td align="left"><br>G</td></tr>
<tr><td><a href="Sigs.PROOF.html#VALget_ancestry">get_ancestry</a> [<a href="Sigs.PROOF.html">Sigs.PROOF</a>]</td>
<td></td></tr>
<tr><td><a href="Sigs.PROOF.html#VALget_seq">get_seq</a> [<a href="Sigs.PROOF.html">Sigs.PROOF</a>]</td>
<td></td></tr>
<tr><td><a href="Sigs.NODE.html#VALget_seq">get_seq</a> [<a href="Sigs.NODE.html">Sigs.NODE</a>]</td>
<td><div class="info">
Get sequent labelling the node.
</div>
</td></tr>
<tr><td><a href="Sigs.NODE.html#VALget_succs">get_succs</a> [<a href="Sigs.NODE.html">Sigs.NODE</a>]</td>
<td><div class="info">
Get the successor node indices of this node.
</div>
</td></tr>
<tr><td align="left"><br>H</td></tr>
<tr><td><a href="Tl_form_ltl.Form.html#VALhash">hash</a> [<a href="Tl_form_ltl.Form.html">Tl_form_ltl.Form</a>]</td>
<td></td></tr>
<tr><td><a href="Tl_form.Form.html#VALhash">hash</a> [<a href="Tl_form.Form.html">Tl_form.Form</a>]</td>
<td></td></tr>
<tr><td><a href="Hashset.HashedType.html#VALhash">hash</a> [<a href="Hashset.HashedType.html">Hashset.HashedType</a>]</td>
<td><div class="info">
A hashing function on elements.
</div>
</td></tr>
<tr><td><a href="Blist.html#VALhd">hd</a> [<a href="Blist.html">Blist</a>]</td>
<td><div class="info">
Return the first element of the given t.
</div>
</td></tr>
<tr><td align="left"><br>I</td></tr>
<tr><td><a href="Sigs.PROOFRULE.html#VALidentity">identity</a> [<a href="Sigs.PROOFRULE.html">Sigs.PROOFRULE</a>]</td>
<td></td></tr>
<tr><td><a href="Sl_heap_rho.html#VALidents">idents</a> [<a href="Sl_heap_rho.html">Sl_heap_rho</a>]</td>
<td><div class="info">
Get multiset of predicate identifiers.
</div>
</td></tr>
<tr><td><a href="Sl_heap.html#VALidents">idents</a> [<a href="Sl_heap.html">Sl_heap</a>]</td>
<td><div class="info">
Get multiset of predicate identifiers.
</div>
</td></tr>
<tr><td><a href="Sl_tpreds.html#VALidents">idents</a> [<a href="Sl_tpreds.html">Sl_tpreds</a>]</td>
<td><div class="info">
Return multiset of identifiers present.
</div>
</td></tr>
<tr><td><a href="Sigs.PROVER.html#VALidfs">idfs</a> [<a href="Sigs.PROVER.html">Sigs.PROVER</a>]</td>
<td></td></tr>
<tr><td><a href="Sl_form_rho.html#VALinconsistent">inconsistent</a> [<a href="Sl_form_rho.html">Sl_form_rho</a>]</td>
<td><div class="info">
Do all disjuncts entail false in the sense of <code class="code">Sl_heap_rho.inconsistent</code>?
</div>
</td></tr>
<tr><td><a href="Sl_form.html#VALinconsistent">inconsistent</a> [<a href="Sl_form.html">Sl_form</a>]</td>
<td><div class="info">
Do all disjuncts entail false in the sense of <code class="code">Sl_heap.inconsistent</code>?
</div>
</td></tr>
<tr><td><a href="Sl_heap_rho.html#VALinconsistent">inconsistent</a> [<a href="Sl_heap_rho.html">Sl_heap_rho</a>]</td>
<td><div class="info">
Trivially false if x=y * x!=y is provable for any x,y.
</div>
</td></tr>
<tr><td><a href="Sl_heap.html#VALinconsistent">inconsistent</a> [<a href="Sl_heap.html">Sl_heap</a>]</td>
<td><div class="info">
Trivially false if x=y * x!=y is provable for any x,y.
</div>
</td></tr>
<tr><td><a href="Blist.html#VALindexes">indexes</a> [<a href="Blist.html">Blist</a>]</td>
<td><div class="info">
<code class="code">indexes l</code> returns the list of integer positions of elements in <code class="code">l</code>.
</div>
</td></tr>
<tr><td><a href="Blist.html#VALintersperse">intersperse</a> [<a href="Blist.html">Blist</a>]</td>
<td><div class="info">
Insert given element between elements of given list.
</div>
</td></tr>
<tr><td><a href="Tl_form.Form.html#VALis_af">is_af</a> [<a href="Tl_form.Form.html">Tl_form.Form</a>]</td>
<td></td></tr>
<tr><td><a href="Tl_form.Form.html#VALis_ag">is_ag</a> [<a href="Tl_form.Form.html">Tl_form.Form</a>]</td>
<td></td></tr>
<tr><td><a href="Tl_form_ltl.Form.html#VALis_and">is_and</a> [<a href="Tl_form_ltl.Form.html">Tl_form_ltl.Form</a>]</td>
<td></td></tr>
<tr><td><a href="Tl_form.Form.html#VALis_and">is_and</a> [<a href="Tl_form.Form.html">Tl_form.Form</a>]</td>
<td></td></tr>
<tr><td><a href="Tl_form_ltl.Form.html#VALis_atom">is_atom</a> [<a href="Tl_form_ltl.Form.html">Tl_form_ltl.Form</a>]</td>
<td></td></tr>
<tr><td><a href="Tl_form.Form.html#VALis_atom">is_atom</a> [<a href="Tl_form.Form.html">Tl_form.Form</a>]</td>
<td></td></tr>
<tr><td><a href="Sigs.NODE.html#VALis_axiom">is_axiom</a> [<a href="Sigs.NODE.html">Sigs.NODE</a>]</td>
<td></td></tr>
<tr><td><a href="Sigs.NODE.html#VALis_backlink">is_backlink</a> [<a href="Sigs.NODE.html">Sigs.NODE</a>]</td>
<td></td></tr>
<tr><td><a href="Tl_form.Form.html#VALis_box">is_box</a> [<a href="Tl_form.Form.html">Tl_form.Form</a>]</td>
<td></td></tr>
<tr><td><a href="Tl_form_ltl.Form.html#VALis_checkable">is_checkable</a> [<a href="Tl_form_ltl.Form.html">Tl_form_ltl.Form</a>]</td>
<td></td></tr>
<tr><td><a href="Tl_form.Form.html#VALis_checkable">is_checkable</a> [<a href="Tl_form.Form.html">Tl_form.Form</a>]</td>
<td></td></tr>
<tr><td><a href="Tl_form.Form.html#VALis_circle">is_circle</a> [<a href="Tl_form.Form.html">Tl_form.Form</a>]</td>
<td></td></tr>
<tr><td><a href="Sigs.PROOF.html#VALis_closed">is_closed</a> [<a href="Sigs.PROOF.html">Sigs.PROOF</a>]</td>
<td><div class="info">
Are all nodes not open?
</div>
</td></tr>
<tr><td><a href="Sigs.PROOF.html#VALis_closed_at">is_closed_at</a> [<a href="Sigs.PROOF.html">Sigs.PROOF</a>]</td>
<td></td></tr>
<tr><td><a href="Tl_form.Form.html#VALis_diamond">is_diamond</a> [<a href="Tl_form.Form.html">Tl_form.Form</a>]</td>
<td></td></tr>
<tr><td><a href="Tl_form.Form.html#VALis_ef">is_ef</a> [<a href="Tl_form.Form.html">Tl_form.Form</a>]</td>
<td></td></tr>
<tr><td><a href="Tl_form.Form.html#VALis_eg">is_eg</a> [<a href="Tl_form.Form.html">Tl_form.Form</a>]</td>
<td></td></tr>
<tr><td><a href="Sl_heap_rho.html#VALis_empty">is_empty</a> [<a href="Sl_heap_rho.html">Sl_heap_rho</a>]</td>
<td><div class="info">
<code class="code">is_empty h</code> tests whether <code class="code">h</code> is equal to the empty heap.
</div>
</td></tr>
<tr><td><a href="Sl_heap.html#VALis_empty">is_empty</a> [<a href="Sl_heap.html">Sl_heap</a>]</td>
<td><div class="info">
<code class="code">is_empty h</code> tests whether <code class="code">h</code> is equal to the empty heap.
</div>
</td></tr>
<tr><td><a href="Sl_rho.html#VALis_empty">is_empty</a> [<a href="Sl_rho.html">Sl_rho</a>]</td>
<td></td></tr>
<tr><td><a href="Sl_uf.html#VALis_empty">is_empty</a> [<a href="Sl_uf.html">Sl_uf</a>]</td>
<td></td></tr>
<tr><td><a href="Hashset.S.html#VALis_empty">is_empty</a> [<a href="Hashset.S.html">Hashset.S</a>]</td>
<td></td></tr>
<tr><td><a href="Blist.html#VALis_empty">is_empty</a> [<a href="Blist.html">Blist</a>]</td>
<td><div class="info">
Is the argument the empty list?
</div>
</td></tr>
<tr><td><a href="Sl_term.html#VALis_exist_var">is_exist_var</a> [<a href="Sl_term.html">Sl_term</a>]</td>
<td><div class="info">
Is the argument an existentially quantified variable?
</div>
</td></tr>
<tr><td><a href="Tl_form_ltl.Form.html#VALis_f">is_f</a> [<a href="Tl_form_ltl.Form.html">Tl_form_ltl.Form</a>]</td>
<td></td></tr>
<tr><td><a href="Tl_form.Form.html#VALis_final">is_final</a> [<a href="Tl_form.Form.html">Tl_form.Form</a>]</td>
<td></td></tr>
<tr><td><a href="Sl_term.html#VALis_free_var">is_free_var</a> [<a href="Sl_term.html">Sl_term</a>]</td>
<td><div class="info">
Is the argument a free variable?
</div>
</td></tr>
<tr><td><a href="Tl_form_ltl.Form.html#VALis_g">is_g</a> [<a href="Tl_form_ltl.Form.html">Tl_form_ltl.Form</a>]</td>
<td></td></tr>
<tr><td><a href="Sigs.NODE.html#VALis_inf">is_inf</a> [<a href="Sigs.NODE.html">Sigs.NODE</a>]</td>
<td></td></tr>
<tr><td><a href="Tl_form_ltl.Form.html#VALis_next">is_next</a> [<a href="Tl_form_ltl.Form.html">Tl_form_ltl.Form</a>]</td>
<td></td></tr>
<tr><td><a href="Sl_term.html#VALis_nil">is_nil</a> [<a href="Sl_term.html">Sl_term</a>]</td>
<td><div class="info">
Is the argument <code class="code">nil</code>? Equivalent to <code class="code">equal nil x</code>.
</div>
</td></tr>
<tr><td><a href="Sigs.NODE.html#VALis_open">is_open</a> [<a href="Sigs.NODE.html">Sigs.NODE</a>]</td>
<td></td></tr>
<tr><td><a href="Tl_form_ltl.Form.html#VALis_or">is_or</a> [<a href="Tl_form_ltl.Form.html">Tl_form_ltl.Form</a>]</td>
<td></td></tr>
<tr><td><a href="Tl_form.Form.html#VALis_or">is_or</a> [<a href="Tl_form.Form.html">Tl_form.Form</a>]</td>
<td></td></tr>
<tr><td><a href="Tl_form_ltl.Form.html#VALis_slformula">is_slformula</a> [<a href="Tl_form_ltl.Form.html">Tl_form_ltl.Form</a>]</td>
<td></td></tr>
<tr><td><a href="Tl_form.Form.html#VALis_slformula">is_slformula</a> [<a href="Tl_form.Form.html">Tl_form.Form</a>]</td>
<td></td></tr>
<tr><td><a href="Sl_form_rho.html#VALis_symheap">is_symheap</a> [<a href="Sl_form_rho.html">Sl_form_rho</a>]</td>
<td><div class="info">
Returns true iff the formula has a single disjunct only
</div>
</td></tr>
<tr><td><a href="Sl_form.html#VALis_symheap">is_symheap</a> [<a href="Sl_form.html">Sl_form</a>]</td>
<td><div class="info">
Returns true iff the formula has a single disjunct only
</div>
</td></tr>
<tr><td><a href="Sl_term.html#VALis_var">is_var</a> [<a href="Sl_term.html">Sl_term</a>]</td>
<td><div class="info">
<code class="code">is_nil x</code> is equivalent to <code class="code">not (equal nil x)</code>.
</div>
</td></tr>
<tr><td><a href="Hashset.S.html#VALiter">iter</a> [<a href="Hashset.S.html">Hashset.S</a>]</td>
<td></td></tr>
<tr><td><a href="Blist.html#VALiter">iter</a> [<a href="Blist.html">Blist</a>]</td>
<td><div class="info">
<code class="code">List.iter f [a1; ...; an]</code> applies function <code class="code">f</code> in turn to
   <code class="code">a1; ...; an</code>.
</div>
</td></tr>
<tr><td><a href="Blist.html#VALiter2">iter2</a> [<a href="Blist.html">Blist</a>]</td>
<td><div class="info">
<code class="code">List.iter2 f [a1; ...; an] [b1; ...; bn]</code> calls in turn
   <code class="code">f a1 b1; ...; f an bn</code>.
</div>
</td></tr>
<tr><td><a href="Blist.html#VALiteri">iteri</a> [<a href="Blist.html">Blist</a>]</td>
<td><div class="info">
Same as <code class="code">List.iter</code>, but the function is applied to the index of
   the element as first argument (counting from 0), and the element
   itself as second argument.
</div>
</td></tr>
<tr><td align="left"><br>L</td></tr>
<tr><td><a href="Sigs.PROVER.html#VALlast_search_depth">last_search_depth</a> [<a href="Sigs.PROVER.html">Sigs.PROVER</a>]</td>
<td></td></tr>
<tr><td><a href="Hashset.S.html#VALleft_union">left_union</a> [<a href="Hashset.S.html">Hashset.S</a>]</td>
<td></td></tr>
<tr><td><a href="Blist.html#VALlength">length</a> [<a href="Blist.html">Blist</a>]</td>
<td><div class="info">
Return the length (number of elements) of the given t.
</div>
</td></tr>
<tr><td><a href="Sigs.ABDRULE.html#VALlift">lift</a> [<a href="Sigs.ABDRULE.html">Sigs.ABDRULE</a>]</td>
<td></td></tr>
<tr><td><a href="Sl_term.UnifierSig.html#VALlift_subst_check">lift_subst_check</a> [<a href="Sl_term.UnifierSig.html">Sl_term.UnifierSig</a>]</td>
<td><div class="info">
<code class="code">lift_subst_check c</code> takes a substitution pair check function <code class="code">c</code> and lifts
        it to a unifier state check function by applying it to each entry in the
        state's substitution map
</div>
</td></tr>
<tr><td><a href="Lru.Make.html#VALlru_cache">lru_cache</a> [<a href="Lru.Make.html">Lru.Make</a>]</td>
<td><div class="info">
<code class="code">lru_cache f n</code> memoises the non-recursive function <code class="code">f</code>, using an LRU cache
      (implemented as a hashtable) of up to <code class="code">n</code> entries.
</div>
</td></tr>
<tr><td><a href="Lru.Make.html#VALlru_cache_rec">lru_cache_rec</a> [<a href="Lru.Make.html">Lru.Make</a>]</td>
<td><div class="info">
<code class="code">lru_cache f n</code> memoises the recursive function <code class="code">f</code>, using an LRU cache
      (implemented as a hashtable) of up to <code class="code">n</code> entries.
</div>
</td></tr>
<tr><td align="left"><br>M</td></tr>
<tr><td><a href="Blist.html#VALmap">map</a> [<a href="Blist.html">Blist</a>]</td>
<td><div class="info">
<code class="code">List.map f [a1; ...; an]</code> applies function <code class="code">f</code> to <code class="code">a1, ..., an</code>,
   and builds the t <code class="code">[f a1; ...; f an]</code>
   with the results returned by <code class="code">f</code>.
</div>
</td></tr>
<tr><td><a href="Blist.html#VALmap2">map2</a> [<a href="Blist.html">Blist</a>]</td>
<td><div class="info">
<code class="code">List.map2 f [a1; ...; an] [b1; ...; bn]</code> is
   <code class="code">[f a1 b1; ...; f an bn]</code>.
</div>
</td></tr>
<tr><td><a href="Hashset.S.html#VALmap_to">map_to</a> [<a href="Hashset.S.html">Hashset.S</a>]</td>
<td></td></tr>
<tr><td><a href="Blist.html#VALmap_to">map_to</a> [<a href="Blist.html">Blist</a>]</td>
<td></td></tr>
<tr><td><a href="Blist.html#VALmapi">mapi</a> [<a href="Blist.html">Blist</a>]</td>
<td><div class="info">
Same as <code class="code">List.map</code>, but the function is applied to the index of
   the element as first argument (counting from 0), and the element
   itself as second argument.
</div>
</td></tr>
<tr><td><a href="Sigs.ABDUCER.html#VALmelt_proof">melt_proof</a> [<a href="Sigs.ABDUCER.html">Sigs.ABDUCER</a>]</td>
<td></td></tr>
<tr><td><a href="Sigs.PROVER.html#VALmelt_proof">melt_proof</a> [<a href="Sigs.PROVER.html">Sigs.PROVER</a>]</td>
<td></td></tr>
<tr><td><a href="Hashset.S.html#VALmem">mem</a> [<a href="Hashset.S.html">Hashset.S</a>]</td>
<td></td></tr>
<tr><td><a href="Blist.html#VALmem">mem</a> [<a href="Blist.html">Blist</a>]</td>
<td><div class="info">
<code class="code">mem a l</code> is true if and only if <code class="code">a</code> is equal
   to an element of <code class="code">l</code>.
</div>
</td></tr>
<tr><td><a href="Blist.html#VALmem_assoc">mem_assoc</a> [<a href="Blist.html">Blist</a>]</td>
<td><div class="info">
Same as <code class="code">List.assoc</code>, but simply return true if a binding exists,
   and false if no bindings exist for the given key.
</div>
</td></tr>
<tr><td><a href="Blist.html#VALmem_assq">mem_assq</a> [<a href="Blist.html">Blist</a>]</td>
<td><div class="info">
Same as <code class="code">List.mem_assoc</code>, but uses physical equality instead of
   structural equality to compare keys.
</div>
</td></tr>
<tr><td><a href="Sl_indrule.html#VALmemory_consuming">memory_consuming</a> [<a href="Sl_indrule.html">Sl_indrule</a>]</td>
<td><div class="info">
<code class="code">memory_consuming r</code> returns <code class="code">true</code> the body of <code class="code">r</code> is memory consuming 
    (see <code class="code">Sl_heap</code>).
</div>
</td></tr>
<tr><td><a href="Sl_heap.html#VALmemory_consuming">memory_consuming</a> [<a href="Sl_heap.html">Sl_heap</a>]</td>
<td><div class="info">
<code class="code">memory_consuming h</code> returns <code class="code">true</code> iff whenever there is an inductive
    predicate in <code class="code">h</code> there is also a points-to.
</div>
</td></tr>
<tr><td><a href="Blist.html#VALmemq">memq</a> [<a href="Blist.html">Blist</a>]</td>
<td><div class="info">
Same as <code class="code">List.mem</code>, but uses physical equality instead of structural
   equality to compare t elements.
</div>
</td></tr>
<tr><td><a href="Blist.html#VALmerge">merge</a> [<a href="Blist.html">Blist</a>]</td>
<td><div class="info">
Merge two ts:
    Assuming that <code class="code">l1</code> and <code class="code">l2</code> are sorted according to the
    comparison function <code class="code">cmp</code>, <code class="code">merge cmp l1 l2</code> will return a
    sorted t containting all the elements of <code class="code">l1</code> and <code class="code">l2</code>.
</div>
</td></tr>
<tr><td><a href="Sl_indrule.html#VALmk">mk</a> [<a href="Sl_indrule.html">Sl_indrule</a>]</td>
<td></td></tr>
<tr><td><a href="Sl_heap_rho.html#VALmk">mk</a> [<a href="Sl_heap_rho.html">Sl_heap_rho</a>]</td>
<td></td></tr>
<tr><td><a href="Sl_heap.html#VALmk">mk</a> [<a href="Sl_heap.html">Sl_heap</a>]</td>
<td></td></tr>
<tr><td><a href="Sigs.PROOF.html#VALmk">mk</a> [<a href="Sigs.PROOF.html">Sigs.PROOF</a>]</td>
<td><div class="info">
Constructor.
</div>
</td></tr>
<tr><td><a href="Sigs.ABDRULE.html#VALmk_abdbackrule">mk_abdbackrule</a> [<a href="Sigs.ABDRULE.html">Sigs.ABDRULE</a>]</td>
<td></td></tr>
<tr><td><a href="Sigs.ABDRULE.html#VALmk_abdgenrule">mk_abdgenrule</a> [<a href="Sigs.ABDRULE.html">Sigs.ABDRULE</a>]</td>
<td></td></tr>
<tr><td><a href="Sigs.ABDRULE.html#VALmk_abdinfrule">mk_abdinfrule</a> [<a href="Sigs.ABDRULE.html">Sigs.ABDRULE</a>]</td>
<td></td></tr>
<tr><td><a href="Soundcheck.html#VALmk_abs_node">mk_abs_node</a> [<a href="Soundcheck.html">Soundcheck</a>]</td>
<td><div class="info">
Constructor for nodes.
</div>
</td></tr>
<tr><td><a href="Tl_form.Form.html#VALmk_af">mk_af</a> [<a href="Tl_form.Form.html">Tl_form.Form</a>]</td>
<td></td></tr>
<tr><td><a href="Tl_form.Form.html#VALmk_ag">mk_ag</a> [<a href="Tl_form.Form.html">Tl_form.Form</a>]</td>
<td></td></tr>
<tr><td><a href="Tl_form_ltl.Form.html#VALmk_and">mk_and</a> [<a href="Tl_form_ltl.Form.html">Tl_form_ltl.Form</a>]</td>
<td></td></tr>
<tr><td><a href="Tl_form.Form.html#VALmk_and">mk_and</a> [<a href="Tl_form.Form.html">Tl_form.Form</a>]</td>
<td></td></tr>
<tr><td><a href="Sl_term.UnifierSig.html#VALmk_assert_check">mk_assert_check</a> [<a href="Sl_term.UnifierSig.html">Sl_term.UnifierSig</a>]</td>
<td><div class="info">
Takes a state check and wraps it in an assert
</div>
</td></tr>
<tr><td><a href="Tl_form_ltl.Form.html#VALmk_atom">mk_atom</a> [<a href="Tl_form_ltl.Form.html">Tl_form_ltl.Form</a>]</td>
<td></td></tr>
<tr><td><a href="Tl_form.Form.html#VALmk_atom">mk_atom</a> [<a href="Tl_form.Form.html">Tl_form.Form</a>]</td>
<td></td></tr>
<tr><td><a href="Sigs.PROOFRULE.html#VALmk_axiom">mk_axiom</a> [<a href="Sigs.PROOFRULE.html">Sigs.PROOFRULE</a>]</td>
<td><div class="info">
Axioms are modeled as functions that return <code class="code">Some string</code> when the 
      input sequent is an instance of an axiom described by <code class="code">string</code>, else
      <code class="code">None</code>.
</div>
</td></tr>
<tr><td><a href="Sigs.NODE.html#VALmk_axiom">mk_axiom</a> [<a href="Sigs.NODE.html">Sigs.NODE</a>]</td>
<td><div class="info">
<code class="code">mk_axiom seq descr</code> creates an axiom node labelled by 
      sequent <code class="code">seq</code> and description <code class="code">descr</code>.
</div>
</td></tr>
<tr><td><a href="Sigs.NODE.html#VALmk_backlink">mk_backlink</a> [<a href="Sigs.NODE.html">Sigs.NODE</a>]</td>
<td><div class="info">
<code class="code">mk_backlink seq descr target vtts</code> creates a back-link node labelled by 
      sequent <code class="code">seq</code>, description <code class="code">descr</code>, target index <code class="code">target</code> and set of 
      valid tag transitions (as pairs) <code class="code">vtts</code>.
</div>
</td></tr>
<tr><td><a href="Sigs.PROOFRULE.html#VALmk_backrule">mk_backrule</a> [<a href="Sigs.PROOFRULE.html">Sigs.PROOFRULE</a>]</td>
<td><div class="info">
Backlink rules take: a boolean <code class="code">eager</code> , a selection function <code class="code">s</code>, a matching function <code class="code">m</code>
      The selection function is applied on the current subgoal and proof, and
      a list of goal indices is returned that represents possible back-link
      targets. This allows flexibility e.g., in changing from ancestral-only
      back-links to general ones.  
      Next, <code class="code">m</code> is applied to every pair consisting of the current subgoal
      and a goal returned from the selection function.
</div>
</td></tr>
<tr><td><a href="Tl_form.Form.html#VALmk_box">mk_box</a> [<a href="Tl_form.Form.html">Tl_form.Form</a>]</td>
<td></td></tr>
<tr><td><a href="Tl_form.Form.html#VALmk_circle">mk_circle</a> [<a href="Tl_form.Form.html">Tl_form.Form</a>]</td>
<td></td></tr>
<tr><td><a href="Sl_heap_rho.html#VALmk_deq">mk_deq</a> [<a href="Sl_heap_rho.html">Sl_heap_rho</a>]</td>
<td></td></tr>
<tr><td><a href="Sl_heap.html#VALmk_deq">mk_deq</a> [<a href="Sl_heap.html">Sl_heap</a>]</td>
<td></td></tr>
<tr><td><a href="Tl_form.Form.html#VALmk_diamond">mk_diamond</a> [<a href="Tl_form.Form.html">Tl_form.Form</a>]</td>
<td></td></tr>
<tr><td><a href="Tl_form.Form.html#VALmk_ef">mk_ef</a> [<a href="Tl_form.Form.html">Tl_form.Form</a>]</td>
<td></td></tr>
<tr><td><a href="Tl_form.Form.html#VALmk_eg">mk_eg</a> [<a href="Tl_form.Form.html">Tl_form.Form</a>]</td>
<td></td></tr>
<tr><td><a href="Sl_heap_rho.html#VALmk_eq">mk_eq</a> [<a href="Sl_heap_rho.html">Sl_heap_rho</a>]</td>
<td></td></tr>
<tr><td><a href="Sl_heap.html#VALmk_eq">mk_eq</a> [<a href="Sl_heap.html">Sl_heap</a>]</td>
<td></td></tr>
<tr><td><a href="Tl_form_ltl.Form.html#VALmk_f">mk_f</a> [<a href="Tl_form_ltl.Form.html">Tl_form_ltl.Form</a>]</td>
<td></td></tr>
<tr><td><a href="Tl_form.Form.html#VALmk_final">mk_final</a> [<a href="Tl_form.Form.html">Tl_form.Form</a>]</td>
<td></td></tr>
<tr><td><a href="Tl_form_ltl.Form.html#VALmk_g">mk_g</a> [<a href="Tl_form_ltl.Form.html">Tl_form_ltl.Form</a>]</td>
<td></td></tr>
<tr><td><a href="Sl_heap_rho.html#VALmk_ind">mk_ind</a> [<a href="Sl_heap_rho.html">Sl_heap_rho</a>]</td>
<td></td></tr>
<tr><td><a href="Sl_heap.html#VALmk_ind">mk_ind</a> [<a href="Sl_heap.html">Sl_heap</a>]</td>
<td></td></tr>
<tr><td><a href="Sigs.NODE.html#VALmk_inf">mk_inf</a> [<a href="Sigs.NODE.html">Sigs.NODE</a>]</td>
<td><div class="info">
<code class="code">mk_inf seq descr subgoals back</code> creates an inference node labelled by 
      sequent <code class="code">seq</code>, description <code class="code">descr</code>, a list of triples consisting of
      subgoal index, valid tag transitions and progressing tag transitions 
      <code class="code">subgoals</code>.
</div>
</td></tr>
<tr><td><a href="Sigs.PROOFRULE.html#VALmk_infrule">mk_infrule</a> [<a href="Sigs.PROOFRULE.html">Sigs.PROOFRULE</a>]</td>
<td><div class="info">
Rules are functions that break down a sequent to a choice of applications
      where each application is a list of premises, including tag information,
      and a description.
</div>
</td></tr>
<tr><td><a href="Tl_form_ltl.Form.html#VALmk_next">mk_next</a> [<a href="Tl_form_ltl.Form.html">Tl_form_ltl.Form</a>]</td>
<td></td></tr>
<tr><td><a href="Sigs.NODE.html#VALmk_open">mk_open</a> [<a href="Sigs.NODE.html">Sigs.NODE</a>]</td>
<td><div class="info">
<code class="code">mk_open seq</code> creates an open Proof.t node labelled by <code class="code">seq</code>.
</div>
</td></tr>
<tr><td><a href="Tl_form_ltl.Form.html#VALmk_or">mk_or</a> [<a href="Tl_form_ltl.Form.html">Tl_form_ltl.Form</a>]</td>
<td></td></tr>
<tr><td><a href="Tl_form.Form.html#VALmk_or">mk_or</a> [<a href="Tl_form.Form.html">Tl_form.Form</a>]</td>
<td></td></tr>
<tr><td><a href="Sl_heap_rho.html#VALmk_pto">mk_pto</a> [<a href="Sl_heap_rho.html">Sl_heap_rho</a>]</td>
<td></td></tr>
<tr><td><a href="Sl_heap.html#VALmk_pto">mk_pto</a> [<a href="Sl_heap.html">Sl_heap</a>]</td>
<td></td></tr>
<tr><td><a href="Sl_heap_rho.html#VALmk_rho">mk_rho</a> [<a href="Sl_heap_rho.html">Sl_heap_rho</a>]</td>
<td></td></tr>
<tr><td><a href="Sl_term.UnifierSig.html#VALmk_verifier">mk_verifier</a> [<a href="Sl_term.UnifierSig.html">Sl_term.UnifierSig</a>]</td>
<td><div class="info">
Takes a state checking function and converts it into a continuation which
        returns None if the check fails
</div>
</td></tr>
<tr><td align="left"><br>N</td></tr>
<tr><td><a href="Sl_term.html#VALnil">nil</a> [<a href="Sl_term.html">Sl_term</a>]</td>
<td><div class="info">
The <code class="code">nil</code> constant.
</div>
</td></tr>
<tr><td><a href="Sl_seq.html#VALnorm">norm</a> [<a href="Sl_seq.html">Sl_seq</a>]</td>
<td><div class="info">
Replace all terms with their UF representatives in the respective formulas.`
</div>
</td></tr>
<tr><td><a href="Sl_form_rho.html#VALnorm">norm</a> [<a href="Sl_form_rho.html">Sl_form_rho</a>]</td>
<td><div class="info">
Replace all terms with their UF representatives in the respective heaps.
</div>
</td></tr>
<tr><td><a href="Sl_form.html#VALnorm">norm</a> [<a href="Sl_form.html">Sl_form</a>]</td>
<td><div class="info">
Replace all terms with their UF representatives in the respective heaps.
</div>
</td></tr>
<tr><td><a href="Sl_heap_rho.html#VALnorm">norm</a> [<a href="Sl_heap_rho.html">Sl_heap_rho</a>]</td>
<td><div class="info">
Replace all terms with their UF representative (the UF in the heap).
</div>
</td></tr>
<tr><td><a href="Sl_heap.html#VALnorm">norm</a> [<a href="Sl_heap.html">Sl_heap</a>]</td>
<td><div class="info">
Replace all terms with their UF representative (the UF in the heap).
</div>
</td></tr>
<tr><td><a href="Sl_tpreds.html#VALnorm">norm</a> [<a href="Sl_tpreds.html">Sl_tpreds</a>]</td>
<td><div class="info">
Replace all terms with their UF representative.
</div>
</td></tr>
<tr><td><a href="Sl_tpred.html#VALnorm">norm</a> [<a href="Sl_tpred.html">Sl_tpred</a>]</td>
<td><div class="info">
Replace all terms with their UF representative.
</div>
</td></tr>
<tr><td><a href="Sl_pred.html#VALnorm">norm</a> [<a href="Sl_pred.html">Sl_pred</a>]</td>
<td><div class="info">
Replace all terms with their UF representative.
</div>
</td></tr>
<tr><td><a href="Sl_ptos.html#VALnorm">norm</a> [<a href="Sl_ptos.html">Sl_ptos</a>]</td>
<td><div class="info">
Replace all terms with their UF representative.
</div>
</td></tr>
<tr><td><a href="Sl_pto.html#VALnorm">norm</a> [<a href="Sl_pto.html">Sl_pto</a>]</td>
<td><div class="info">
Replace all terms with their UF representative.
</div>
</td></tr>
<tr><td><a href="Sl_deqs.html#VALnorm">norm</a> [<a href="Sl_deqs.html">Sl_deqs</a>]</td>
<td><div class="info">
Rename all variables involved by their representative in the UF structure 
    and re-order pair members if necessary.
</div>
</td></tr>
<tr><td><a href="Blist.html#VALnth">nth</a> [<a href="Blist.html">Blist</a>]</td>
<td><div class="info">
Return the <code class="code">n</code>-th element of the given t.
</div>
</td></tr>
<tr><td align="left"><br>O</td></tr>
<tr><td><a href="Sl_rho.html#VALof_list">of_list</a> [<a href="Sl_rho.html">Sl_rho</a>]</td>
<td></td></tr>
<tr><td><a href="Sl_uf.html#VALof_list">of_list</a> [<a href="Sl_uf.html">Sl_uf</a>]</td>
<td><div class="info">
<code class="code">Sl_term.compare</code>.
</div>
</td></tr>
<tr><td><a href="Hashset.S.html#VALof_list">of_list</a> [<a href="Hashset.S.html">Hashset.S</a>]</td>
<td></td></tr>
<tr><td><a href="Blist.html#VALof_list">of_list</a> [<a href="Blist.html">Blist</a>]</td>
<td><div class="info">
Construct a <code class="code">t</code> list out of a primitive list.
</div>
</td></tr>
<tr><td><a href="Tl_form_ltl.Form.html#VALof_string">of_string</a> [<a href="Tl_form_ltl.Form.html">Tl_form_ltl.Form</a>]</td>
<td></td></tr>
<tr><td><a href="Tl_form.Form.html#VALof_string">of_string</a> [<a href="Tl_form.Form.html">Tl_form.Form</a>]</td>
<td></td></tr>
<tr><td><a href="Sl_seq.html#VALof_string">of_string</a> [<a href="Sl_seq.html">Sl_seq</a>]</td>
<td></td></tr>
<tr><td><a href="Sl_form_rho.html#VALof_string">of_string</a> [<a href="Sl_form_rho.html">Sl_form_rho</a>]</td>
<td></td></tr>
<tr><td><a href="Sl_form.html#VALof_string">of_string</a> [<a href="Sl_form.html">Sl_form</a>]</td>
<td></td></tr>
<tr><td><a href="Sl_heap_rho.html#VALof_string">of_string</a> [<a href="Sl_heap_rho.html">Sl_heap_rho</a>]</td>
<td></td></tr>
<tr><td><a href="Sl_heap.html#VALof_string">of_string</a> [<a href="Sl_heap.html">Sl_heap</a>]</td>
<td></td></tr>
<tr><td><a href="Sl_tpred.html#VALof_string">of_string</a> [<a href="Sl_tpred.html">Sl_tpred</a>]</td>
<td></td></tr>
<tr><td><a href="Sl_pred.html#VALof_string">of_string</a> [<a href="Sl_pred.html">Sl_pred</a>]</td>
<td></td></tr>
<tr><td><a href="Sl_term.html#VALof_string">of_string</a> [<a href="Sl_term.html">Sl_term</a>]</td>
<td><div class="info">
Parse a term from a string.
</div>
</td></tr>
<tr><td><a href="Sl_tpair.html#VALorder">order</a> [<a href="Sl_tpair.html">Sl_tpair</a>]</td>
<td><div class="info">
Return a permutation of the input that obeys the ordering <code class="code">Sl_term.compare</code>.
</div>
</td></tr>
<tr><td><a href="Tl_form_ltl.Form.html#VALoutermost_tag">outermost_tag</a> [<a href="Tl_form_ltl.Form.html">Tl_form_ltl.Form</a>]</td>
<td></td></tr>
<tr><td><a href="Tl_form.Form.html#VALoutermost_tag">outermost_tag</a> [<a href="Tl_form.Form.html">Tl_form.Form</a>]</td>
<td></td></tr>
<tr><td align="left"><br>P</td></tr>
<tr><td><a href="Blist.html#VALpairs">pairs</a> [<a href="Blist.html">Blist</a>]</td>
<td><div class="info">
Return a list of pairs of consecutive elements.
</div>
</td></tr>
<tr><td><a href="Tl_form_ltl.Form.html#VALparse">parse</a> [<a href="Tl_form_ltl.Form.html">Tl_form_ltl.Form</a>]</td>
<td></td></tr>
<tr><td><a href="Tl_form.Form.html#VALparse">parse</a> [<a href="Tl_form.Form.html">Tl_form.Form</a>]</td>
<td></td></tr>
<tr><td><a href="Sl_indrule.html#VALparse">parse</a> [<a href="Sl_indrule.html">Sl_indrule</a>]</td>
<td></td></tr>
<tr><td><a href="Sl_seq.html#VALparse">parse</a> [<a href="Sl_seq.html">Sl_seq</a>]</td>
<td></td></tr>
<tr><td><a href="Sl_form_rho.html#VALparse">parse</a> [<a href="Sl_form_rho.html">Sl_form_rho</a>]</td>
<td></td></tr>
<tr><td><a href="Sl_form.html#VALparse">parse</a> [<a href="Sl_form.html">Sl_form</a>]</td>
<td></td></tr>
<tr><td><a href="Sl_heap_rho.html#VALparse">parse</a> [<a href="Sl_heap_rho.html">Sl_heap_rho</a>]</td>
<td></td></tr>
<tr><td><a href="Sl_heap.html#VALparse">parse</a> [<a href="Sl_heap.html">Sl_heap</a>]</td>
<td></td></tr>
<tr><td><a href="Sl_tpred.html#VALparse">parse</a> [<a href="Sl_tpred.html">Sl_tpred</a>]</td>
<td></td></tr>
<tr><td><a href="Sl_pred.html#VALparse">parse</a> [<a href="Sl_pred.html">Sl_pred</a>]</td>
<td></td></tr>
<tr><td><a href="Sl_pto.html#VALparse">parse</a> [<a href="Sl_pto.html">Sl_pto</a>]</td>
<td></td></tr>
<tr><td><a href="Sl_deqs.html#VALparse">parse</a> [<a href="Sl_deqs.html">Sl_deqs</a>]</td>
<td></td></tr>
<tr><td><a href="Sl_rho.html#VALparse">parse</a> [<a href="Sl_rho.html">Sl_rho</a>]</td>
<td></td></tr>
<tr><td><a href="Sl_uf.html#VALparse">parse</a> [<a href="Sl_uf.html">Sl_uf</a>]</td>
<td></td></tr>
<tr><td><a href="Sl_term.html#VALparse">parse</a> [<a href="Sl_term.html">Sl_term</a>]</td>
<td><div class="info">
Parse a term.
</div>
</td></tr>
<tr><td><a href="Blist.html#VALpartition">partition</a> [<a href="Blist.html">Blist</a>]</td>
<td><div class="info">
<code class="code">partition p l</code> returns a pair of ts <code class="code">(l1, l2)</code>, where
   <code class="code">l1</code> is the t of all the elements of <code class="code">l</code> that
   satisfy the predicate <code class="code">p</code>, and <code class="code">l2</code> is the t of all the
   elements of <code class="code">l</code> that do not satisfy <code class="code">p</code>.
</div>
</td></tr>
<tr><td><a href="Tl_form_ltl.Form.html#VALpp">pp</a> [<a href="Tl_form_ltl.Form.html">Tl_form_ltl.Form</a>]</td>
<td></td></tr>
<tr><td><a href="Tl_form.Form.html#VALpp">pp</a> [<a href="Tl_form.Form.html">Tl_form.Form</a>]</td>
<td></td></tr>
<tr><td><a href="Sl_term.SubstSig.html#VALpp">pp</a> [<a href="Sl_term.SubstSig.html">Sl_term.SubstSig</a>]</td>
<td><div class="info">
Pretty printer.
</div>
</td></tr>
<tr><td><a href="Soundcheck.html#VALpp">pp</a> [<a href="Soundcheck.html">Soundcheck</a>]</td>
<td><div class="info">
Pretty print abstract proof.
</div>
</td></tr>
<tr><td><a href="Sigs.PROOF.html#VALpp">pp</a> [<a href="Sigs.PROOF.html">Sigs.PROOF</a>]</td>
<td></td></tr>
<tr><td><a href="Sigs.NODE.html#VALpp">pp</a> [<a href="Sigs.NODE.html">Sigs.NODE</a>]</td>
<td></td></tr>
<tr><td><a href="Sigs.DEFS.html#VALpp">pp</a> [<a href="Sigs.DEFS.html">Sigs.DEFS</a>]</td>
<td></td></tr>
<tr><td><a href="Sigs.SEQUENT.html#VALpp">pp</a> [<a href="Sigs.SEQUENT.html">Sigs.SEQUENT</a>]</td>
<td></td></tr>
<tr><td><a href="Blist.html#VALpp">pp</a> [<a href="Blist.html">Blist</a>]</td>
<td><div class="info">
<code class="code">pp sep e fmt l</code> pretty prints the list <code class="code">l</code>.
</div>
</td></tr>
<tr><td><a href="Sl_indrule.html#VALpredsym">predsym</a> [<a href="Sl_indrule.html">Sl_indrule</a>]</td>
<td></td></tr>
<tr><td><a href="Sl_tpred.html#VALpredsym">predsym</a> [<a href="Sl_tpred.html">Sl_tpred</a>]</td>
<td></td></tr>
<tr><td><a href="Sl_pred.html#VALpredsym">predsym</a> [<a href="Sl_pred.html">Sl_pred</a>]</td>
<td></td></tr>
<tr><td><a href="Sigs.ABDUCER.html#VALprint_proof_stats">print_proof_stats</a> [<a href="Sigs.ABDUCER.html">Sigs.ABDUCER</a>]</td>
<td></td></tr>
<tr><td><a href="Sigs.PROVER.html#VALprint_proof_stats">print_proof_stats</a> [<a href="Sigs.PROVER.html">Sigs.PROVER</a>]</td>
<td></td></tr>
<tr><td><a href="Sl_heap_rho.html#VALproj_pure">proj_pure</a> [<a href="Sl_heap_rho.html">Sl_heap_rho</a>]</td>
<td></td></tr>
<tr><td><a href="Sl_heap.html#VALproj_pure">proj_pure</a> [<a href="Sl_heap.html">Sl_heap</a>]</td>
<td></td></tr>
<tr><td><a href="Sl_heap_rho.html#VALproj_sp">proj_sp</a> [<a href="Sl_heap_rho.html">Sl_heap_rho</a>]</td>
<td></td></tr>
<tr><td><a href="Sl_heap.html#VALproj_sp">proj_sp</a> [<a href="Sl_heap.html">Sl_heap</a>]</td>
<td></td></tr>
<tr><td><a href="Sl_heap_rho.html#VALproject">project</a> [<a href="Sl_heap_rho.html">Sl_heap_rho</a>]</td>
<td><div class="info">
See CSL-LICS paper for explanation.
</div>
</td></tr>
<tr><td><a href="Sl_heap.html#VALproject">project</a> [<a href="Sl_heap.html">Sl_heap</a>]</td>
<td><div class="info">
See CSL-LICS paper for explanation.
</div>
</td></tr>
<tr><td align="left"><br>R</td></tr>
<tr><td><a href="Blist.html#VALrange">range</a> [<a href="Blist.html">Blist</a>]</td>
<td><div class="info">
<code class="code">range n l</code> returns a list of increasing integers <code class="code">li</code> such that <code class="code">hd li = n</code>
and <code class="code">length li = length l</code>.
</div>
</td></tr>
<tr><td><a href="Sl_pto.html#VALrecord_type">record_type</a> [<a href="Sl_pto.html">Sl_pto</a>]</td>
<td></td></tr>
<tr><td><a href="Sigs.SEQTACTICS.html#VALrelabel">relabel</a> [<a href="Sigs.SEQTACTICS.html">Sigs.SEQTACTICS</a>]</td>
<td></td></tr>
<tr><td><a href="Sl_uf.html#VALremove">remove</a> [<a href="Sl_uf.html">Sl_uf</a>]</td>
<td><div class="info">
FIXME why is this here?
</div>
</td></tr>
<tr><td><a href="Hashset.S.html#VALremove">remove</a> [<a href="Hashset.S.html">Hashset.S</a>]</td>
<td></td></tr>
<tr><td><a href="Blist.html#VALremove_assoc">remove_assoc</a> [<a href="Blist.html">Blist</a>]</td>
<td><div class="info">
<code class="code">remove_assoc a l</code> returns the t of
   pairs <code class="code">l</code> without the first pair with key <code class="code">a</code>, if any.
</div>
</td></tr>
<tr><td><a href="Blist.html#VALremove_assq">remove_assq</a> [<a href="Blist.html">Blist</a>]</td>
<td><div class="info">
Same as <code class="code">List.remove_assoc</code>, but uses physical equality instead
   of structural equality to compare keys.
</div>
</td></tr>
<tr><td><a href="Blist.html#VALremove_nth">remove_nth</a> [<a href="Blist.html">Blist</a>]</td>
<td></td></tr>
<tr><td><a href="Sigs.SEQTACTICS.html#VALrepeat">repeat</a> [<a href="Sigs.SEQTACTICS.html">Sigs.SEQTACTICS</a>]</td>
<td></td></tr>
<tr><td><a href="Blist.html#VALrepeat">repeat</a> [<a href="Blist.html">Blist</a>]</td>
<td><div class="info">
<code class="code">repeat e n</code> constructs a list of length <code class="code">n</code> where all elements are physically 
equal to <code class="code">e</code>.
</div>
</td></tr>
<tr><td><a href="Blist.html#VALreplace_nth">replace_nth</a> [<a href="Blist.html">Blist</a>]</td>
<td></td></tr>
<tr><td><a href="Blist.html#VALrev">rev</a> [<a href="Blist.html">Blist</a>]</td>
<td><div class="info">
List reversal.
</div>
</td></tr>
<tr><td><a href="Blist.html#VALrev_append">rev_append</a> [<a href="Blist.html">Blist</a>]</td>
<td><div class="info">
<code class="code">List.rev_append l1 l2</code> reverses <code class="code">l1</code> and concatenates it to <code class="code">l2</code>.
</div>
</td></tr>
<tr><td><a href="Blist.html#VALrev_filter">rev_filter</a> [<a href="Blist.html">Blist</a>]</td>
<td></td></tr>
<tr><td><a href="Blist.html#VALrev_map">rev_map</a> [<a href="Blist.html">Blist</a>]</td>
<td><div class="info">
<code class="code">List.rev_map f l</code> gives the same result as
   <code class="code">List.rev</code><code class="code"> (</code><code class="code">List.map</code><code class="code"> f l)</code>, but is tail-recursive and
   more efficient.
</div>
</td></tr>
<tr><td><a href="Blist.html#VALrev_map2">rev_map2</a> [<a href="Blist.html">Blist</a>]</td>
<td><div class="info">
<code class="code">List.rev_map2 f l1 l2</code> gives the same result as
   <code class="code">List.rev</code><code class="code"> (</code><code class="code">List.map2</code><code class="code"> f l1 l2)</code>, but is tail-recursive and
   more efficient.
</div>
</td></tr>
<tr><td align="left"><br>S</td></tr>
<tr><td><a href="Sigs.PROOFRULE.html#VALsequence">sequence</a> [<a href="Sigs.PROOFRULE.html">Sigs.PROOFRULE</a>]</td>
<td></td></tr>
<tr><td><a href="Sl_term.SubstSig.html#VALsingleton">singleton</a> [<a href="Sl_term.SubstSig.html">Sl_term.SubstSig</a>]</td>
<td><div class="info">
Constructor for a substitution mapping one variable to a term.
</div>
</td></tr>
<tr><td><a href="Blist.html#VALsingleton">singleton</a> [<a href="Blist.html">Blist</a>]</td>
<td><div class="info">
Constructs a list with exactly one element, the argument provided.
</div>
</td></tr>
<tr><td><a href="Sigs.PROOF.html#VALsize">size</a> [<a href="Sigs.PROOF.html">Sigs.PROOF</a>]</td>
<td></td></tr>
<tr><td><a href="Blist.html#VALsort">sort</a> [<a href="Blist.html">Blist</a>]</td>
<td><div class="info">
Sort a t in increasing order according to a comparison
   function.
</div>
</td></tr>
<tr><td><a href="Blist.html#VALsort_uniq">sort_uniq</a> [<a href="Blist.html">Blist</a>]</td>
<td><div class="info">
Same as <code class="code">List.sort</code>, but also remove duplicates.
</div>
</td></tr>
<tr><td><a href="Blist.html#VALsplit">split</a> [<a href="Blist.html">Blist</a>]</td>
<td><div class="info">
Transform a t of pairs into a pair of ts:
   <code class="code">split [(a1,b1); ...; (an,bn)]</code> is <code class="code">([a1; ...; an], [b1; ...; bn])</code>.
</div>
</td></tr>
<tr><td><a href="Blist.html#VALstable_sort">stable_sort</a> [<a href="Blist.html">Blist</a>]</td>
<td><div class="info">
Same as <code class="code">List.sort</code>, but the sorting algorithm is guaranteed to
   be stable (i.e.
</div>
</td></tr>
<tr><td><a href="Sl_form_rho.html#VALstar">star</a> [<a href="Sl_form_rho.html">Sl_form_rho</a>]</td>
<td><div class="info">
Star two formulas by distributing <code class="code">*</code> through <code class="code">\/</code>.
</div>
</td></tr>
<tr><td><a href="Sl_form.html#VALstar">star</a> [<a href="Sl_form.html">Sl_form</a>]</td>
<td><div class="info">
Star two formulas by distributing <code class="code">*</code> through <code class="code">\/</code>.
</div>
</td></tr>
<tr><td><a href="Sl_heap_rho.html#VALstar">star</a> [<a href="Sl_heap_rho.html">Sl_heap_rho</a>]</td>
<td></td></tr>
<tr><td><a href="Sl_heap.html#VALstar">star</a> [<a href="Sl_heap.html">Sl_heap</a>]</td>
<td></td></tr>
<tr><td><a href="Tl_form_ltl.Form.html#VALstep">step</a> [<a href="Tl_form_ltl.Form.html">Tl_form_ltl.Form</a>]</td>
<td></td></tr>
<tr><td><a href="Sl_tpreds.html#VALstrip_tags">strip_tags</a> [<a href="Sl_tpreds.html">Sl_tpreds</a>]</td>
<td><div class="info">
Remove tags.
</div>
</td></tr>
<tr><td><a href="Sl_indrule.html#VALsubst">subst</a> [<a href="Sl_indrule.html">Sl_indrule</a>]</td>
<td></td></tr>
<tr><td><a href="Sl_seq.html#VALsubst">subst</a> [<a href="Sl_seq.html">Sl_seq</a>]</td>
<td></td></tr>
<tr><td><a href="Sl_form_rho.html#VALsubst">subst</a> [<a href="Sl_form_rho.html">Sl_form_rho</a>]</td>
<td></td></tr>
<tr><td><a href="Sl_form.html#VALsubst">subst</a> [<a href="Sl_form.html">Sl_form</a>]</td>
<td></td></tr>
<tr><td><a href="Sl_heap_rho.html#VALsubst">subst</a> [<a href="Sl_heap_rho.html">Sl_heap_rho</a>]</td>
<td></td></tr>
<tr><td><a href="Sl_heap.html#VALsubst">subst</a> [<a href="Sl_heap.html">Sl_heap</a>]</td>
<td></td></tr>
<tr><td><a href="Sl_tpreds.html#VALsubst">subst</a> [<a href="Sl_tpreds.html">Sl_tpreds</a>]</td>
<td></td></tr>
<tr><td><a href="Sl_tpred.html#VALsubst">subst</a> [<a href="Sl_tpred.html">Sl_tpred</a>]</td>
<td></td></tr>
<tr><td><a href="Sl_pred.html#VALsubst">subst</a> [<a href="Sl_pred.html">Sl_pred</a>]</td>
<td></td></tr>
<tr><td><a href="Sl_ptos.html#VALsubst">subst</a> [<a href="Sl_ptos.html">Sl_ptos</a>]</td>
<td></td></tr>
<tr><td><a href="Sl_pto.html#VALsubst">subst</a> [<a href="Sl_pto.html">Sl_pto</a>]</td>
<td></td></tr>
<tr><td><a href="Sl_deqs.html#VALsubst">subst</a> [<a href="Sl_deqs.html">Sl_deqs</a>]</td>
<td></td></tr>
<tr><td><a href="Sl_rho.html#VALsubst">subst</a> [<a href="Sl_rho.html">Sl_rho</a>]</td>
<td></td></tr>
<tr><td><a href="Sl_uf.html#VALsubst">subst</a> [<a href="Sl_uf.html">Sl_uf</a>]</td>
<td></td></tr>
<tr><td><a href="Sl_tpair.html#VALsubst">subst</a> [<a href="Sl_tpair.html">Sl_tpair</a>]</td>
<td></td></tr>
<tr><td><a href="Sl_term.FList.html#VALsubst">subst</a> [<a href="Sl_term.FList.html">Sl_term.FList</a>]</td>
<td></td></tr>
<tr><td><a href="Sl_term.html#VALsubst">subst</a> [<a href="Sl_term.html">Sl_term</a>]</td>
<td><div class="info">
Apply a substitution on the given term.
</div>
</td></tr>
<tr><td><a href="Sl_form_rho.html#VALsubst_existentials">subst_existentials</a> [<a href="Sl_form_rho.html">Sl_form_rho</a>]</td>
<td><div class="info">
Like <code class="code">Sl_heap_rho.subst_existentials</code> applied to all disjuncts.
</div>
</td></tr>
<tr><td><a href="Sl_form.html#VALsubst_existentials">subst_existentials</a> [<a href="Sl_form.html">Sl_form</a>]</td>
<td><div class="info">
Like <code class="code">Sl_heap.subst_existentials</code> applied to all disjuncts.
</div>
</td></tr>
<tr><td><a href="Sl_heap_rho.html#VALsubst_existentials">subst_existentials</a> [<a href="Sl_heap_rho.html">Sl_heap_rho</a>]</td>
<td><div class="info">
For all equalities x'=t, remove the equality and do the substitution <code class="code">t/x'</code>
</div>
</td></tr>
<tr><td><a href="Sl_heap.html#VALsubst_existentials">subst_existentials</a> [<a href="Sl_heap.html">Sl_heap</a>]</td>
<td><div class="info">
For all equalities x'=t, remove the equality and do the substitution <code class="code">t/x'</code>
</div>
</td></tr>
<tr><td><a href="Sl_uf.html#VALsubst_subsumed">subst_subsumed</a> [<a href="Sl_uf.html">Sl_uf</a>]</td>
<td><div class="info">
Compute whether a substitution could be obtained by rewriting under 
    equalities in first argument.
</div>
</td></tr>
<tr><td><a href="Sl_tpred.html#VALsubst_tag">subst_tag</a> [<a href="Sl_tpred.html">Sl_tpred</a>]</td>
<td><div class="info">
Substitute the tag according to the function represented by the set of 
    tag pairs provided.
</div>
</td></tr>
<tr><td><a href="Tl_form_ltl.Form.html#VALsubst_tags">subst_tags</a> [<a href="Tl_form_ltl.Form.html">Tl_form_ltl.Form</a>]</td>
<td></td></tr>
<tr><td><a href="Tl_form.Form.html#VALsubst_tags">subst_tags</a> [<a href="Tl_form.Form.html">Tl_form.Form</a>]</td>
<td></td></tr>
<tr><td><a href="Sl_seq.html#VALsubst_tags">subst_tags</a> [<a href="Sl_seq.html">Sl_seq</a>]</td>
<td><div class="info">
Substitute tags of the LHS.
</div>
</td></tr>
<tr><td><a href="Sl_form_rho.html#VALsubst_tags">subst_tags</a> [<a href="Sl_form_rho.html">Sl_form_rho</a>]</td>
<td><div class="info">
Like <code class="code">Sl_heap_rho.subst_tags</code> applied to all disjuncts.
</div>
</td></tr>
<tr><td><a href="Sl_form.html#VALsubst_tags">subst_tags</a> [<a href="Sl_form.html">Sl_form</a>]</td>
<td><div class="info">
Like <code class="code">Sl_heap.subst_tags</code> applied to all disjuncts.
</div>
</td></tr>
<tr><td><a href="Sl_heap_rho.html#VALsubst_tags">subst_tags</a> [<a href="Sl_heap_rho.html">Sl_heap_rho</a>]</td>
<td><div class="info">
Substitute tags according to the function represented by the set of 
    tag pairs provided.
</div>
</td></tr>
<tr><td><a href="Sl_heap.html#VALsubst_tags">subst_tags</a> [<a href="Sl_heap.html">Sl_heap</a>]</td>
<td><div class="info">
Substitute tags according to the function represented by the set of 
    tag pairs provided.
</div>
</td></tr>
<tr><td><a href="Sl_tpreds.html#VALsubst_tags">subst_tags</a> [<a href="Sl_tpreds.html">Sl_tpreds</a>]</td>
<td><div class="info">
Substitute tags according to the function represented by the set of 
    tag pairs provided.
</div>
</td></tr>
<tr><td><a href="Sl_seq.html#VALsubsumed">subsumed</a> [<a href="Sl_seq.html">Sl_seq</a>]</td>
<td><div class="info">
<code class="code">subsumed (l,r) (l',r')</code> is true iff <code class="code">Sl_form.subsumed l' l</code> and
    <code class="code">Sl_form.subsumed_upto_tags r r'</code> are true.
</div>
</td></tr>
<tr><td><a href="Sl_form_rho.html#VALsubsumed">subsumed</a> [<a href="Sl_form_rho.html">Sl_form_rho</a>]</td>
<td><div class="info">
<code class="code">subsumed a b</code>: is it the case that for any disjunct <code class="code">a'</code> of <code class="code">a</code> there a 
    disjunct <code class="code">b'</code> of <code class="code">b</code> such <code class="code">a'</code> is subsumed by <code class="code">b'</code>?
    If the optional argument <code class="code">~total=true</code> is set to <code class="code">false</code> then relax the 
    check on the spatial part so that it is included rather than equal to that
    of <code class="code">b</code>.
</div>
</td></tr>
<tr><td><a href="Sl_form.html#VALsubsumed">subsumed</a> [<a href="Sl_form.html">Sl_form</a>]</td>
<td><div class="info">
<code class="code">subsumed a b</code>: is it the case that for any disjunct <code class="code">a'</code> of <code class="code">a</code> there a 
    disjunct <code class="code">b'</code> of <code class="code">b</code> such <code class="code">a'</code> is subsumed by <code class="code">b'</code>?
    If the optional argument <code class="code">~total=true</code> is set to <code class="code">false</code> then relax the 
    check on the spatial part so that it is included rather than equal to that
    of <code class="code">b</code>.
</div>
</td></tr>
<tr><td><a href="Sl_heap_rho.html#VALsubsumed">subsumed</a> [<a href="Sl_heap_rho.html">Sl_heap_rho</a>]</td>
<td><div class="info">
<code class="code">subsumed h h'</code> is true iff <code class="code">h</code> can be rewritten using the equalities
    in <code class="code">h'</code> such that its spatial part becomes equal to that of <code class="code">h'</code>
    and the pure part becomes a subset of that of <code class="code">h'</code>.
</div>
</td></tr>
<tr><td><a href="Sl_heap.html#VALsubsumed">subsumed</a> [<a href="Sl_heap.html">Sl_heap</a>]</td>
<td><div class="info">
<code class="code">subsumed h h'</code> is true iff <code class="code">h</code> can be rewritten using the equalities
    in <code class="code">h'</code> such that its spatial part becomes equal to that of <code class="code">h'</code>
    and the pure part becomes a subset of that of <code class="code">h'</code>.
</div>
</td></tr>
<tr><td><a href="Sl_tpreds.html#VALsubsumed">subsumed</a> [<a href="Sl_tpreds.html">Sl_tpreds</a>]</td>
<td><div class="info">
Test whether the two arguments are the same modulo the provided equalities.
</div>
</td></tr>
<tr><td><a href="Sl_ptos.html#VALsubsumed">subsumed</a> [<a href="Sl_ptos.html">Sl_ptos</a>]</td>
<td><div class="info">
<code class="code">subsumed eqs ptos ptos'</code> is true iff <code class="code">ptos</code> can be rewritten using the 
    equalities <code class="code">eqs</code> such that it becomes equal to <code class="code">ptos'</code>.
</div>
</td></tr>
<tr><td><a href="Sl_deqs.html#VALsubsumed">subsumed</a> [<a href="Sl_deqs.html">Sl_deqs</a>]</td>
<td><div class="info">
<code class="code">subsumed eqs d d'</code> is true iff <code class="code">d</code> can be rewritten using the equalities
    in <code class="code">eqs</code> such that it becomes a subset of <code class="code">d'</code>.
</div>
</td></tr>
<tr><td><a href="Sl_rho.html#VALsubsumed">subsumed</a> [<a href="Sl_rho.html">Sl_rho</a>]</td>
<td><div class="info">
<code class="code">subsumed rho rho'</code> is true iff uf' |- uf using the normal equality rules.
</div>
</td></tr>
<tr><td><a href="Sl_uf.html#VALsubsumed">subsumed</a> [<a href="Sl_uf.html">Sl_uf</a>]</td>
<td><div class="info">
<code class="code">subsumed uf uf'</code> is true iff uf' |- uf using the normal equality rules.
</div>
</td></tr>
<tr><td><a href="Sl_seq.html#VALsubsumed_upto_tags">subsumed_upto_tags</a> [<a href="Sl_seq.html">Sl_seq</a>]</td>
<td><div class="info">
Like <code class="code">subsumed</code> but ignoring all tags.
</div>
</td></tr>
<tr><td><a href="Sl_form_rho.html#VALsubsumed_upto_tags">subsumed_upto_tags</a> [<a href="Sl_form_rho.html">Sl_form_rho</a>]</td>
<td><div class="info">
As above but ignoring tags.
</div>
</td></tr>
<tr><td><a href="Sl_form.html#VALsubsumed_upto_tags">subsumed_upto_tags</a> [<a href="Sl_form.html">Sl_form</a>]</td>
<td><div class="info">
As above but ignoring tags.
</div>
</td></tr>
<tr><td><a href="Sl_heap_rho.html#VALsubsumed_upto_tags">subsumed_upto_tags</a> [<a href="Sl_heap_rho.html">Sl_heap_rho</a>]</td>
<td><div class="info">
Like <code class="code">subsumed</code> but ignoring tag assignment.
</div>
</td></tr>
<tr><td><a href="Sl_heap.html#VALsubsumed_upto_tags">subsumed_upto_tags</a> [<a href="Sl_heap.html">Sl_heap</a>]</td>
<td><div class="info">
Like <code class="code">subsumed</code> but ignoring tag assignment.
</div>
</td></tr>
<tr><td><a href="Sl_tpreds.html#VALsubsumed_upto_tags">subsumed_upto_tags</a> [<a href="Sl_tpreds.html">Sl_tpreds</a>]</td>
<td><div class="info">
Test whether the two arguments are the same modulo the provided equalities.
</div>
</td></tr>
<tr><td align="left"><br>T</td></tr>
<tr><td><a href="Sl_seq.html#VALtag_pairs">tag_pairs</a> [<a href="Sl_seq.html">Sl_seq</a>]</td>
<td><div class="info">
Only LHS tag pairs are returned.
</div>
</td></tr>
<tr><td><a href="Sl_form_rho.html#VALtag_pairs">tag_pairs</a> [<a href="Sl_form_rho.html">Sl_form_rho</a>]</td>
<td><div class="info">
The proviso on tags applies here too.
</div>
</td></tr>
<tr><td><a href="Sl_form.html#VALtag_pairs">tag_pairs</a> [<a href="Sl_form.html">Sl_form</a>]</td>
<td><div class="info">
The proviso on tags applies here too.
</div>
</td></tr>
<tr><td><a href="Sl_heap_rho.html#VALtag_pairs">tag_pairs</a> [<a href="Sl_heap_rho.html">Sl_heap_rho</a>]</td>
<td><div class="info">
Return a set of pairs representing the identity function over the tags 
    of the formula.
</div>
</td></tr>
<tr><td><a href="Sl_heap.html#VALtag_pairs">tag_pairs</a> [<a href="Sl_heap.html">Sl_heap</a>]</td>
<td><div class="info">
Return a set of pairs representing the identity function over the tags 
    of the formula.
</div>
</td></tr>
<tr><td><a href="Tl_form_ltl.Form.html#VALtags">tags</a> [<a href="Tl_form_ltl.Form.html">Tl_form_ltl.Form</a>]</td>
<td></td></tr>
<tr><td><a href="Tl_form.Form.html#VALtags">tags</a> [<a href="Tl_form.Form.html">Tl_form.Form</a>]</td>
<td></td></tr>
<tr><td><a href="Sl_seq.html#VALtags">tags</a> [<a href="Sl_seq.html">Sl_seq</a>]</td>
<td><div class="info">
Only LHS tags are returned.
</div>
</td></tr>
<tr><td><a href="Sl_form_rho.html#VALtags">tags</a> [<a href="Sl_form_rho.html">Sl_form_rho</a>]</td>
<td><div class="info">
NB no attempt is made to ensure that tags are disjoint between disjuncts.
</div>
</td></tr>
<tr><td><a href="Sl_form.html#VALtags">tags</a> [<a href="Sl_form.html">Sl_form</a>]</td>
<td><div class="info">
NB no attempt is made to ensure that tags are disjoint between disjuncts.
</div>
</td></tr>
<tr><td><a href="Sl_heap_rho.html#VALtags">tags</a> [<a href="Sl_heap_rho.html">Sl_heap_rho</a>]</td>
<td><div class="info">
Return set of tags assigned to predicates in heap.
</div>
</td></tr>
<tr><td><a href="Sl_heap.html#VALtags">tags</a> [<a href="Sl_heap.html">Sl_heap</a>]</td>
<td><div class="info">
Return set of tags assigned to predicates in heap.
</div>
</td></tr>
<tr><td><a href="Sl_tpreds.html#VALtags">tags</a> [<a href="Sl_tpreds.html">Sl_tpreds</a>]</td>
<td></td></tr>
<tr><td><a href="Sl_tpred.html#VALtags">tags</a> [<a href="Sl_tpred.html">Sl_tpred</a>]</td>
<td></td></tr>
<tr><td><a href="Sigs.SEQUENT.html#VALtags">tags</a> [<a href="Sigs.SEQUENT.html">Sigs.SEQUENT</a>]</td>
<td><div class="info">
Returns set of tags in sequent.
</div>
</td></tr>
<tr><td><a href="Blist.html#VALtake">take</a> [<a href="Blist.html">Blist</a>]</td>
<td><div class="info">
<code class="code">take n l</code> returns a list of the first <code class="code">n</code> elements of <code class="code">l</code>.
</div>
</td></tr>
<tr><td><a href="Sl_form_rho.html#VALterms">terms</a> [<a href="Sl_form_rho.html">Sl_form_rho</a>]</td>
<td></td></tr>
<tr><td><a href="Sl_form.html#VALterms">terms</a> [<a href="Sl_form.html">Sl_form</a>]</td>
<td></td></tr>
<tr><td><a href="Sl_heap_rho.html#VALterms">terms</a> [<a href="Sl_heap_rho.html">Sl_heap_rho</a>]</td>
<td></td></tr>
<tr><td><a href="Sl_heap.html#VALterms">terms</a> [<a href="Sl_heap.html">Sl_heap</a>]</td>
<td></td></tr>
<tr><td><a href="Sl_tpreds.html#VALterms">terms</a> [<a href="Sl_tpreds.html">Sl_tpreds</a>]</td>
<td></td></tr>
<tr><td><a href="Sl_tpred.html#VALterms">terms</a> [<a href="Sl_tpred.html">Sl_tpred</a>]</td>
<td></td></tr>
<tr><td><a href="Sl_pred.html#VALterms">terms</a> [<a href="Sl_pred.html">Sl_pred</a>]</td>
<td></td></tr>
<tr><td><a href="Sl_ptos.html#VALterms">terms</a> [<a href="Sl_ptos.html">Sl_ptos</a>]</td>
<td></td></tr>
<tr><td><a href="Sl_pto.html#VALterms">terms</a> [<a href="Sl_pto.html">Sl_pto</a>]</td>
<td></td></tr>
<tr><td><a href="Sl_deqs.html#VALterms">terms</a> [<a href="Sl_deqs.html">Sl_deqs</a>]</td>
<td></td></tr>
<tr><td><a href="Sl_rho.html#VALterms">terms</a> [<a href="Sl_rho.html">Sl_rho</a>]</td>
<td></td></tr>
<tr><td><a href="Sl_uf.html#VALterms">terms</a> [<a href="Sl_uf.html">Sl_uf</a>]</td>
<td></td></tr>
<tr><td><a href="Sl_tpair.FList.html#VALterms">terms</a> [<a href="Sl_tpair.FList.html">Sl_tpair.FList</a>]</td>
<td></td></tr>
<tr><td><a href="Sl_term.FList.html#VALterms">terms</a> [<a href="Sl_term.FList.html">Sl_term.FList</a>]</td>
<td></td></tr>
<tr><td><a href="Blist.html#VALtl">tl</a> [<a href="Blist.html">Blist</a>]</td>
<td><div class="info">
Return the given t without its first element.
</div>
</td></tr>
<tr><td><a href="Sigs.NODE.html#VALto_abstract_node">to_abstract_node</a> [<a href="Sigs.NODE.html">Sigs.NODE</a>]</td>
<td><div class="info">
Convert Proof.t node to abstract node as in <a href="Soundcheck.html"><code class="code">Soundcheck</code></a>.
</div>
</td></tr>
<tr><td><a href="Sigs.PROOF.html#VALto_list">to_list</a> [<a href="Sigs.PROOF.html">Sigs.PROOF</a>]</td>
<td></td></tr>
<tr><td><a href="Hashset.S.html#VALto_list">to_list</a> [<a href="Hashset.S.html">Hashset.S</a>]</td>
<td></td></tr>
<tr><td><a href="Blist.html#VALto_list">to_list</a> [<a href="Blist.html">Blist</a>]</td>
<td><div class="info">
Construct a primitive list out of a <code class="code">t</code> list.
</div>
</td></tr>
<tr><td><a href="Tl_form_ltl.Form.html#VALto_melt">to_melt</a> [<a href="Tl_form_ltl.Form.html">Tl_form_ltl.Form</a>]</td>
<td></td></tr>
<tr><td><a href="Tl_form.Form.html#VALto_melt">to_melt</a> [<a href="Tl_form.Form.html">Tl_form.Form</a>]</td>
<td></td></tr>
<tr><td><a href="Sl_seq.html#VALto_melt">to_melt</a> [<a href="Sl_seq.html">Sl_seq</a>]</td>
<td></td></tr>
<tr><td><a href="Sl_form_rho.html#VALto_melt">to_melt</a> [<a href="Sl_form_rho.html">Sl_form_rho</a>]</td>
<td></td></tr>
<tr><td><a href="Sl_form.html#VALto_melt">to_melt</a> [<a href="Sl_form.html">Sl_form</a>]</td>
<td></td></tr>
<tr><td><a href="Sl_heap_rho.html#VALto_melt">to_melt</a> [<a href="Sl_heap_rho.html">Sl_heap_rho</a>]</td>
<td></td></tr>
<tr><td><a href="Sl_heap.html#VALto_melt">to_melt</a> [<a href="Sl_heap.html">Sl_heap</a>]</td>
<td></td></tr>
<tr><td><a href="Sl_tpreds.html#VALto_melt">to_melt</a> [<a href="Sl_tpreds.html">Sl_tpreds</a>]</td>
<td></td></tr>
<tr><td><a href="Sl_tpred.html#VALto_melt">to_melt</a> [<a href="Sl_tpred.html">Sl_tpred</a>]</td>
<td></td></tr>
<tr><td><a href="Sl_ptos.html#VALto_melt">to_melt</a> [<a href="Sl_ptos.html">Sl_ptos</a>]</td>
<td></td></tr>
<tr><td><a href="Sl_pto.html#VALto_melt">to_melt</a> [<a href="Sl_pto.html">Sl_pto</a>]</td>
<td></td></tr>
<tr><td><a href="Sl_deqs.html#VALto_melt">to_melt</a> [<a href="Sl_deqs.html">Sl_deqs</a>]</td>
<td></td></tr>
<tr><td><a href="Sl_rho.html#VALto_melt">to_melt</a> [<a href="Sl_rho.html">Sl_rho</a>]</td>
<td></td></tr>
<tr><td><a href="Sl_uf.html#VALto_melt">to_melt</a> [<a href="Sl_uf.html">Sl_uf</a>]</td>
<td></td></tr>
<tr><td><a href="Sl_term.html#VALto_melt">to_melt</a> [<a href="Sl_term.html">Sl_term</a>]</td>
<td><div class="info">
Convert term to LaTeX.
</div>
</td></tr>
<tr><td><a href="Sigs.PROOF.html#VALto_melt">to_melt</a> [<a href="Sigs.PROOF.html">Sigs.PROOF</a>]</td>
<td></td></tr>
<tr><td><a href="Sigs.NODE.html#VALto_melt">to_melt</a> [<a href="Sigs.NODE.html">Sigs.NODE</a>]</td>
<td><div class="info">
Convert to Latex.
</div>
</td></tr>
<tr><td><a href="Sigs.DEFS.html#VALto_melt">to_melt</a> [<a href="Sigs.DEFS.html">Sigs.DEFS</a>]</td>
<td></td></tr>
<tr><td><a href="Sigs.SEQUENT.html#VALto_melt">to_melt</a> [<a href="Sigs.SEQUENT.html">Sigs.SEQUENT</a>]</td>
<td></td></tr>
<tr><td><a href="Sl_tpair.html#VALto_melt_sep">to_melt_sep</a> [<a href="Sl_tpair.html">Sl_tpair</a>]</td>
<td></td></tr>
<tr><td><a href="Tl_form_ltl.Form.html#VALto_slformula">to_slformula</a> [<a href="Tl_form_ltl.Form.html">Tl_form_ltl.Form</a>]</td>
<td></td></tr>
<tr><td><a href="Tl_form.Form.html#VALto_slformula">to_slformula</a> [<a href="Tl_form.Form.html">Tl_form.Form</a>]</td>
<td></td></tr>
<tr><td><a href="Tl_form_ltl.Form.html#VALto_string">to_string</a> [<a href="Tl_form_ltl.Form.html">Tl_form_ltl.Form</a>]</td>
<td></td></tr>
<tr><td><a href="Tl_form.Form.html#VALto_string">to_string</a> [<a href="Tl_form.Form.html">Tl_form.Form</a>]</td>
<td></td></tr>
<tr><td><a href="Sl_tpred.html#VALto_string">to_string</a> [<a href="Sl_tpred.html">Sl_tpred</a>]</td>
<td></td></tr>
<tr><td><a href="Sigs.PROOF.html#VALto_string">to_string</a> [<a href="Sigs.PROOF.html">Sigs.PROOF</a>]</td>
<td></td></tr>
<tr><td><a href="Sigs.DEFS.html#VALto_string">to_string</a> [<a href="Sigs.DEFS.html">Sigs.DEFS</a>]</td>
<td></td></tr>
<tr><td><a href="Sigs.SEQUENT.html#VALto_string">to_string</a> [<a href="Sigs.SEQUENT.html">Sigs.SEQUENT</a>]</td>
<td></td></tr>
<tr><td><a href="Hashset.HashedType.html#VALto_string">to_string</a> [<a href="Hashset.HashedType.html">Hashset.HashedType</a>]</td>
<td></td></tr>
<tr><td><a href="Hashset.S.html#VALto_string">to_string</a> [<a href="Hashset.S.html">Hashset.S</a>]</td>
<td></td></tr>
<tr><td><a href="Blist.html#VALto_string">to_string</a> [<a href="Blist.html">Blist</a>]</td>
<td><div class="info">
<code class="code">to_string sep e l</code> converts the list <code class="code">l</code> to a string.
</div>
</td></tr>
<tr><td><a href="Sl_tpreds.html#VALto_string_list">to_string_list</a> [<a href="Sl_tpreds.html">Sl_tpreds</a>]</td>
<td></td></tr>
<tr><td><a href="Sl_ptos.html#VALto_string_list">to_string_list</a> [<a href="Sl_ptos.html">Sl_ptos</a>]</td>
<td></td></tr>
<tr><td><a href="Sl_deqs.html#VALto_string_list">to_string_list</a> [<a href="Sl_deqs.html">Sl_deqs</a>]</td>
<td></td></tr>
<tr><td><a href="Sl_rho.html#VALto_string_list">to_string_list</a> [<a href="Sl_rho.html">Sl_rho</a>]</td>
<td></td></tr>
<tr><td><a href="Sl_uf.html#VALto_string_list">to_string_list</a> [<a href="Sl_uf.html">Sl_uf</a>]</td>
<td></td></tr>
<tr><td><a href="Sl_tpair.html#VALto_string_sep">to_string_sep</a> [<a href="Sl_tpair.html">Sl_tpair</a>]</td>
<td></td></tr>
<tr><td><a href="Sl_term.FList.html#VALto_string_sep">to_string_sep</a> [<a href="Sl_term.FList.html">Sl_term.FList</a>]</td>
<td></td></tr>
<tr><td><a href="Sl_term.SubstSig.html#VALtrivial_check">trivial_check</a> [<a href="Sl_term.SubstSig.html">Sl_term.SubstSig</a>]</td>
<td><div class="info">
The check that is always true.
</div>
</td></tr>
<tr><td><a href="Sl_term.UnifierSig.html#VALtrivial_continuation">trivial_continuation</a> [<a href="Sl_term.UnifierSig.html">Sl_term.UnifierSig</a>]</td>
<td></td></tr>
<tr><td align="left"><br>U</td></tr>
<tr><td><a href="Sl_indrule.html#VALunfold">unfold</a> [<a href="Sl_indrule.html">Sl_indrule</a>]</td>
<td><div class="info">
<code class="code">unfold vars h p r</code> does the following: Removes the (tagged) occurrence of <code class="code">p</code> in <code class="code">h</code>., Inlines the body of <code class="code">r</code> in <code class="code">h</code>, taking care to pick existential variables
  outside <code class="code">vars</code>., Returns the tag pairs representing progressing tag pairs. I.e. if <code class="code">p</code> is equal
  to <code class="code">(tag, pred)</code> then new tags will be introduced for all predicates in the
  body of <code class="code">r</code> (disjoint to those in <code class="code">h</code>), and for each such new tag <code class="code">tag'</code> the
  pair <code class="code">(tag,tag')</code> will be returned.
</div>
</td></tr>
<tr><td><a href="Tl_form.Form.html#VALunfold_af">unfold_af</a> [<a href="Tl_form.Form.html">Tl_form.Form</a>]</td>
<td></td></tr>
<tr><td><a href="Tl_form.Form.html#VALunfold_ag">unfold_ag</a> [<a href="Tl_form.Form.html">Tl_form.Form</a>]</td>
<td></td></tr>
<tr><td><a href="Tl_form_ltl.Form.html#VALunfold_and">unfold_and</a> [<a href="Tl_form_ltl.Form.html">Tl_form_ltl.Form</a>]</td>
<td></td></tr>
<tr><td><a href="Tl_form.Form.html#VALunfold_and">unfold_and</a> [<a href="Tl_form.Form.html">Tl_form.Form</a>]</td>
<td></td></tr>
<tr><td><a href="Tl_form.Form.html#VALunfold_ef">unfold_ef</a> [<a href="Tl_form.Form.html">Tl_form.Form</a>]</td>
<td></td></tr>
<tr><td><a href="Tl_form.Form.html#VALunfold_eg">unfold_eg</a> [<a href="Tl_form.Form.html">Tl_form.Form</a>]</td>
<td></td></tr>
<tr><td><a href="Tl_form_ltl.Form.html#VALunfold_f">unfold_f</a> [<a href="Tl_form_ltl.Form.html">Tl_form_ltl.Form</a>]</td>
<td></td></tr>
<tr><td><a href="Tl_form_ltl.Form.html#VALunfold_g">unfold_g</a> [<a href="Tl_form_ltl.Form.html">Tl_form_ltl.Form</a>]</td>
<td></td></tr>
<tr><td><a href="Tl_form_ltl.Form.html#VALunfold_or">unfold_or</a> [<a href="Tl_form_ltl.Form.html">Tl_form_ltl.Form</a>]</td>
<td></td></tr>
<tr><td><a href="Tl_form.Form.html#VALunfold_or">unfold_or</a> [<a href="Tl_form.Form.html">Tl_form.Form</a>]</td>
<td></td></tr>
<tr><td><a href="Sl_tpreds.html#VALunify">unify</a> [<a href="Sl_tpreds.html">Sl_tpreds</a>]</td>
<td><div class="info">
Compute substitution that makes the two multisets equal up to tags.
</div>
</td></tr>
<tr><td><a href="Sl_tpred.html#VALunify">unify</a> [<a href="Sl_tpred.html">Sl_tpred</a>]</td>
<td><div class="info">
Unify two tagged predicates.
</div>
</td></tr>
<tr><td><a href="Sl_pred.html#VALunify">unify</a> [<a href="Sl_pred.html">Sl_pred</a>]</td>
<td><div class="info">
Compute substitution that unifies two predicates.
</div>
</td></tr>
<tr><td><a href="Sl_ptos.html#VALunify">unify</a> [<a href="Sl_ptos.html">Sl_ptos</a>]</td>
<td><div class="info">
Compute substitution that would make the two multisets equal.
</div>
</td></tr>
<tr><td><a href="Sl_pto.html#VALunify">unify</a> [<a href="Sl_pto.html">Sl_pto</a>]</td>
<td><div class="info">
Compute substitution that unifies two points-tos.
</div>
</td></tr>
<tr><td><a href="Sl_tpair.html#VALunify">unify</a> [<a href="Sl_tpair.html">Sl_tpair</a>]</td>
<td><div class="info">
Unify two pairs of terms, ignoring the pairs' internal ordering of members.
</div>
</td></tr>
<tr><td><a href="Sl_term.FList.html#VALunify">unify</a> [<a href="Sl_term.FList.html">Sl_term.FList</a>]</td>
<td></td></tr>
<tr><td><a href="Sl_term.html#VALunify">unify</a> [<a href="Sl_term.html">Sl_term</a>]</td>
<td><div class="info">
<code class="code">unify check cont state o o'</code> should try to extend <code class="code">state</code> so that <code class="code">o</code> is 
    unified with <code class="code">o'</code>, extending the variable substitution inside <code class="code">state</code>.
</div>
</td></tr>
<tr><td><a href="Sl_heap_rho.html#VALunify_partial">unify_partial</a> [<a href="Sl_heap_rho.html">Sl_heap_rho</a>]</td>
<td><div class="info">
Unify two heaps such that the first becomes a subformula of the second.
</div>
</td></tr>
<tr><td><a href="Sl_heap.html#VALunify_partial">unify_partial</a> [<a href="Sl_heap.html">Sl_heap</a>]</td>
<td><div class="info">
Unify two heaps such that the first becomes a subformula of the second.
</div>
</td></tr>
<tr><td><a href="Sl_deqs.html#VALunify_partial">unify_partial</a> [<a href="Sl_deqs.html">Sl_deqs</a>]</td>
<td><div class="info">
<code class="code">unify_partial Option.some (Sl_subst.empty, ()) d d'</code> computes a 
    substitution <code class="code">theta</code> such that <code class="code">d[theta]</code> is a subset of <code class="code">d'</code>.
</div>
</td></tr>
<tr><td><a href="Sl_uf.html#VALunify_partial">unify_partial</a> [<a href="Sl_uf.html">Sl_uf</a>]</td>
<td><div class="info">
<code class="code">unify_partial Option.some (Sl_subst.empty, ()) u u'</code> computes a 
    substitution <code class="code">theta</code> such that <code class="code">u'</code> |- <code class="code">u[theta]</code>.
</div>
</td></tr>
<tr><td><a href="Sl_tpair.FList.html#VALunify_partial">unify_partial</a> [<a href="Sl_tpair.FList.html">Sl_tpair.FList</a>]</td>
<td><div class="info">
Unify all pairs of the 1st argument with a part of the 2nd.
</div>
</td></tr>
<tr><td><a href="Sl_rho.html#VALunion">union</a> [<a href="Sl_rho.html">Sl_rho</a>]</td>
<td></td></tr>
<tr><td><a href="Sl_uf.html#VALunion">union</a> [<a href="Sl_uf.html">Sl_uf</a>]</td>
<td></td></tr>
<tr><td><a href="Blist.html#VALuniq">uniq</a> [<a href="Blist.html">Blist</a>]</td>
<td><div class="info">
<code class="code">uniq eq l</code> returns a list containing no duplicates w.r.t.
</div>
</td></tr>
<tr><td><a href="Sl_heap_rho.html#VALuniv">univ</a> [<a href="Sl_heap_rho.html">Sl_heap_rho</a>]</td>
<td><div class="info">
Replace all existential variables with fresh universal variables.
</div>
</td></tr>
<tr><td><a href="Sl_heap.html#VALuniv">univ</a> [<a href="Sl_heap.html">Sl_heap</a>]</td>
<td><div class="info">
Replace all existential variables with fresh universal variables.
</div>
</td></tr>
<tr><td><a href="Blist.html#VALunzip3">unzip3</a> [<a href="Blist.html">Blist</a>]</td>
<td></td></tr>
<tr><td align="left"><br>V</td></tr>
<tr><td><a href="Tl_form_ltl.Form.html#VALvars">vars</a> [<a href="Tl_form_ltl.Form.html">Tl_form_ltl.Form</a>]</td>
<td></td></tr>
<tr><td><a href="Tl_form.Form.html#VALvars">vars</a> [<a href="Tl_form.Form.html">Tl_form.Form</a>]</td>
<td></td></tr>
<tr><td><a href="Sl_indrule.html#VALvars">vars</a> [<a href="Sl_indrule.html">Sl_indrule</a>]</td>
<td></td></tr>
<tr><td><a href="Sl_seq.html#VALvars">vars</a> [<a href="Sl_seq.html">Sl_seq</a>]</td>
<td></td></tr>
<tr><td><a href="Sl_form_rho.html#VALvars">vars</a> [<a href="Sl_form_rho.html">Sl_form_rho</a>]</td>
<td></td></tr>
<tr><td><a href="Sl_form.html#VALvars">vars</a> [<a href="Sl_form.html">Sl_form</a>]</td>
<td></td></tr>
<tr><td><a href="Sl_heap_rho.html#VALvars">vars</a> [<a href="Sl_heap_rho.html">Sl_heap_rho</a>]</td>
<td></td></tr>
<tr><td><a href="Sl_heap.html#VALvars">vars</a> [<a href="Sl_heap.html">Sl_heap</a>]</td>
<td></td></tr>
<tr><td><a href="Sl_tpreds.html#VALvars">vars</a> [<a href="Sl_tpreds.html">Sl_tpreds</a>]</td>
<td></td></tr>
<tr><td><a href="Sl_tpred.html#VALvars">vars</a> [<a href="Sl_tpred.html">Sl_tpred</a>]</td>
<td></td></tr>
<tr><td><a href="Sl_pred.html#VALvars">vars</a> [<a href="Sl_pred.html">Sl_pred</a>]</td>
<td></td></tr>
<tr><td><a href="Sl_ptos.html#VALvars">vars</a> [<a href="Sl_ptos.html">Sl_ptos</a>]</td>
<td></td></tr>
<tr><td><a href="Sl_pto.html#VALvars">vars</a> [<a href="Sl_pto.html">Sl_pto</a>]</td>
<td></td></tr>
<tr><td><a href="Sl_deqs.html#VALvars">vars</a> [<a href="Sl_deqs.html">Sl_deqs</a>]</td>
<td></td></tr>
<tr><td><a href="Sl_rho.html#VALvars">vars</a> [<a href="Sl_rho.html">Sl_rho</a>]</td>
<td></td></tr>
<tr><td><a href="Sl_uf.html#VALvars">vars</a> [<a href="Sl_uf.html">Sl_uf</a>]</td>
<td></td></tr>
<tr><td><a href="Sl_term.FList.html#VALvars">vars</a> [<a href="Sl_term.FList.html">Sl_term.FList</a>]</td>
<td></td></tr>
<tr><td align="left"><br>W</td></tr>
<tr><td><a href="Blist.html#VALweave">weave</a> [<a href="Blist.html">Blist</a>]</td>
<td><div class="info">
Weave combinator - used in the SL Model Checker.
</div>
</td></tr>
<tr><td><a href="Sl_heap_rho.html#VALwith_deqs">with_deqs</a> [<a href="Sl_heap_rho.html">Sl_heap_rho</a>]</td>
<td></td></tr>
<tr><td><a href="Sl_heap.html#VALwith_deqs">with_deqs</a> [<a href="Sl_heap.html">Sl_heap</a>]</td>
<td></td></tr>
<tr><td><a href="Sl_heap_rho.html#VALwith_eqs">with_eqs</a> [<a href="Sl_heap_rho.html">Sl_heap_rho</a>]</td>
<td></td></tr>
<tr><td><a href="Sl_heap.html#VALwith_eqs">with_eqs</a> [<a href="Sl_heap.html">Sl_heap</a>]</td>
<td></td></tr>
<tr><td><a href="Sl_heap_rho.html#VALwith_inds">with_inds</a> [<a href="Sl_heap_rho.html">Sl_heap_rho</a>]</td>
<td></td></tr>
<tr><td><a href="Sl_heap.html#VALwith_inds">with_inds</a> [<a href="Sl_heap.html">Sl_heap</a>]</td>
<td></td></tr>
<tr><td><a href="Sl_heap_rho.html#VALwith_ptos">with_ptos</a> [<a href="Sl_heap_rho.html">Sl_heap_rho</a>]</td>
<td></td></tr>
<tr><td><a href="Sl_heap.html#VALwith_ptos">with_ptos</a> [<a href="Sl_heap.html">Sl_heap</a>]</td>
<td></td></tr>
<tr><td><a href="Sl_heap_rho.html#VALwith_rho">with_rho</a> [<a href="Sl_heap_rho.html">Sl_heap_rho</a>]</td>
<td></td></tr>
<tr><td align="left"><br>Z</td></tr>
<tr><td><a href="Blist.html#VALzip3">zip3</a> [<a href="Blist.html">Blist</a>]</td>
<td></td></tr>
</table>
</body>
</html>