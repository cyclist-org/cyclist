module type Kernel = 
  sig
    val map : string Int.Hashmap.t
    val inv_map : int Strng.Hashmap.t
    val max_var : int ref
    val min_var : int ref
    val default_varname : bool -> string
    val unnamed_varname : string
  end
  
module type I =
  sig
    type var
    type var_container

    val unnamed : var
    (** An "unidentified" variable *)
    val is_unnamed : var Fun.predicate
    (** [is_unnamed v] returns [true] if and only if [v] is an "unidentified" variable *)
    val present : var Fun.predicate
    (** [present v] returns true if and only if the VarManager "knows" about [v].
        This will be the case if the variable has been returned from [mk_var] or
        one of the functions that generate fresh variables. *)
    val name_present : string Fun.predicate
    (** [name_present n] returns true if and only if the VarManager "knows" about 
        the variable name [n]. This will be the case if a variable has been created
        from [n] using [mk_var] or [n] has been automatically generated by one of the 
        functions that generate fresh variables. *)
    val get_var : string -> var
    (** [get_var n] returns the variable with name [n], or raises Not_found if it
        does not know about any variable named [n]. *)
    val mk_var : string -> bool -> var
    (** [mk_var n exist] returns a variable with name [n]; if [exist] is [true] then 
        the returned variable will be existential, otherwise it will be free. If the 
        VarManager already knows about a variable named [n], then this will be returned,
        otherwise it will generate a fresh variable. *)
    val is_exist_var : var Fun.predicate
    (** [is_exist_var v] returns [true] if and only if [v] is an existential variable. *)
    val is_free_var : var Fun.predicate
    (** [is_exist_var v] returns [true] if and only if [v] is a free variable. *)
    val is_exist_name : string Fun.predicate
    (** [is_exist_name s] returns [true] if and only if [s] is a valid name for an existential variable. *)
    val is_free_name : string Fun.predicate
    (** [is_exist_name s] returns [true] if and only if [s] is a valid name for a free variable. *)
    val fresh_evar : var_container -> var
    (** [fresh_evar s] returns an existential variable that is fresh for the set of variables [s]. *)
    val fresh_evars : var_container -> int -> var list
    (** [fresh_evars s n] returns [n] distinct existential variables that are all fresh for the set of variables [s]. *)
    val fresh_fvar : var_container -> var
    (** [fresh_uvar s] returns a free variable that is fresh for the set of variables [s]. *)
    val fresh_fvars : var_container -> int -> var list
    (** [fresh_uvars s n] returns [n] distinct free variables that are all fresh for the set of variables [s]. *)
  end
  
module type SubstSig =
  sig
    type t
    (** Abstract type of substitutions *)
    type var
    (** Abstract type of variables substituted *)
    type var_container
    (** abstract type of containers of variables *)
    val empty : t
    (** The empty substitution, which has no effect when applied. *)
    val singleton : var -> var -> t
    (** Constructor for a substitution mapping one variable to a term. *)
    val of_list : (var * var) list -> t
    (** Make a substitution from a list of bindings *)
    val avoid : var_container -> var_container -> t
    (** [avoid vars subvars] 
        returns a substitution that takes all variables in [subvars] to  
        variables fresh in [vars U subvars], respecting existential   
        quantification / free variables. *)
    val pp : Format.formatter -> t -> unit
    (** Pretty printer. *)
    val to_string : t -> string
    (** Convert a substitution to a string *)
    val apply : t -> var -> var
    (** Apply a substitution to a variable *)
    val partition : t -> t * t
    (** [partition theta] will partition [theta] into ([theta_1], [theta_2])
        such that [theta_1] contains all and only the mappings in [theta] from 
        a free variable to either an unnamed variable or another free variable; 
        that is [theta_1] is the part of [theta] which is a proper
        (proof-theoretic) substitution. *)
    val strip : t -> t
    (** Removes all identity bindings from the substitution map *)
    val mk_free_subst : var_container -> var_container -> t
    (** [mk_free_subst avoid vs] produces a substitution of pairwise distinct
        free variables (fresh for all the variables in [avoid]) for the variables in [vs]. *)
    val mk_ex_subst : var_container -> var_container -> t
    (** [mk_ex_subst avoid vs] produces a substitution of pairwise distinct existentially
        quantified variables (fresh for all the variables in [avoid]) for the variables in [vs]. *)
  end

module type S =
  sig
    module Var : 
      sig
        include Utilsigs.BasicType
        
        include Containers.S 
          with type Set.elt=t
          with type Map.key=t
          with type Hashmap.key=t
          with type Hashset.elt=t
          with type MSet.elt=t
          with type FList.t=t list
          
        val to_int : t -> Int.t
        (** Returns the underlying integer representation *)
      end
    (** Abstract type of variables *)

    module Subst : SubstSig 
      with type t = Var.t Var.Map.t
      with type var = Var.t
      with type var_container = Var.Set.t

    include I with type var = Var.t and type var_container = Var.Set.t
    
    val to_ints : Var.Set.t -> Int.Set.t
    (** Convenience method to return the underlying representation of a set of variables.
        This is equivalent to [Var.Set.map_to Int.Set.add Int.Set.empty Var.to_int] *)

  end
  
module Make(T : Kernel) : S
(** Create a VarManager *)
